
# 简介
当你深入 Rust 更高级的角落时，重要的是你要确保你对基本原理有着扎实的理解。在 Rust 中，和任何其他编程语言一样：各种关键字的准确含义和概念很重要，因为你开始
以更复杂的方式使用语言。 在本章节，我们将遍历 Rust 的许多原语并尝试更清楚地定义它们的含义、它们的工作原理以及它们为何完全如此。具体来说，我们将研究变量和值有何不同，它们在内存中的表示方式，以及程序具有的不同内存区域。 然后，我们将讨论您在继续阅读本书之前需要掌握的所有权、借用和生命周期的一些微妙之处。
如果愿意，您可以从头到尾阅读本章，也可以将其作为参考来温习您不太确定的概念。 我建议您在完全掌握本章的内容后再继续后续的阅读，因为对这些原语如何工作的误解会很快妨碍你理解更高级的主题，或者导致你错误地使用它们。

## 谈谈内存
并非所有的内存都是平等的。在大多数编程环境下，你的程序可以访问栈（stack）、堆（heap）、寄存器（register）、文本段（text segment）、内存映射的寄存器（memory-mapped register）、内存映射文件（memory-mapped file），有时也会有非易失性可读写存储器（Nonvolatile RAM）。在特定的情况下，你选择使用哪一个会影响到你可以在那里存储什么、可以保持多长时间，以及使用什么机制来访问它。这些内存区域细节因平台而异，超出了本书的范围，但有些内存区域堆你如何推理 Rust 代码非常重要，因此值得在此介绍。

### 内存术语
在深入研究内存区域之前，你首先需要了解 值（value）、变量（variable）和指针（pointer）之间的区别。Rust 中的值是一个类型和该类型值域[2]中的一个元素的组合。一个值可以根据其类型表征（type's representation）变成一串字节，但就这个词的本意而言，你可以认为一个值更像是“你 --程序员”这样的组合。例如， u8 类型中的数字 6是数学整数6的一个实例，它在内存中的表示是字节 0x06。同样，字符串 "hello world"是所有字符串域中的一个值，使用 UTF-8 编码来表示。一个值的意义与这些字节的存储位置无关。
值被存储于某个位置。位置（place）是 Rust 中的术语，意思是“一个可以容纳值的地方”。这个位置可以是栈，也可以是堆，或者是其他的某些位置。最常见的存储值的位置是一个变量，它是位于栈中的一个命名值槽（value slot）。指针是一个持有内存区域地址的值，所以指针指向某个位置。
我们可以通过解引用（dereference）指针来访问存储在它所指向内存位置的值。也可以在多个变量中存储相同的指针，这些变量正确地指向内存中的同一个位置，从而指向相同的值。
考虑清单 2-1 中的代码，它阐明了三个要素。
```
let x = 42; 
let y = 43;
let var1 = &x;
let mut var2 = &x;
var2 = &y;
```

代码中包含四个不同的值：42（i32 类型）、43（i32 类型）、x的地址（指针类型），以及 y 的地址（指针类型）。代码中也包含四个变量：x、y、var1 和 var2。后两个变量都持有指针类型的值，因为引用（reference）就是指针。虽然 var1 和 var2 最初存储的都是同一个值，但它们分布存储该值的独立副本。当我们改变 var2 (1) 存储的值时， var1 中的值不会改变。尤其是当 = 运算符将右侧表达式（expression）的值存储在左侧命名的地方。  
在一个语句（statement）中，变量、值和指针之间的区别很重要。下面是一个有趣的示例：
```
let string = "Hello world";
```
尽管我们给变量 string 赋予了一个字符串的值，但该变量的值实际上是一个指针，而不是字符串值本身。此时，你可能会说：“你等等，那么字符串的值是在哪里存储的呢？指针指向哪里？”。如果你真这么想，那说明你有一个敏锐的头脑。我们接下来就会解释这些问题。

### 理解变量
我前面给出的变量定义很宽泛，而且本身不太可能有什么用。当你遇到更复杂的代码时，你将需要一个更精准的心智模型（mental model）来帮助你推理程序的真正作用。我们可以利用许多这样的模型。详细描述这些模型会占用好几章的篇幅，也超出了本书的范围，但大致上它们可以分为两类：抽象模型（high-level model）和底层模型（low-level model）。抽象模型在思考生存期和借用层面的代码时很有用，而底层模型在推理 Unsafe 代码和 原始指针时很有用。下面两节中描述的变量模型对于本书中大部分内容来说已经足够了。

### high-level model
在抽象模型下，我们不认为变量是存放字节的地方。相反，我们认为它们只是在整个程序中被实例化、移动和使用时赋值的名称。当你给变量赋值的时候，这个值就以此变量为名。当变量在之后被访问时，你可以在脑海中从该变量之前的访问到最新的访问之间画一条线，来确定两个访问之间的依赖关系。如果变量的值被移动了，就不能再从它那里画线了。

在该模型中，只要一个变量持有合法的值，它就存在。如果一个变量的值未被初始化或被移动了，你就不能从它那里画线了，所以实际上它并不存在。使用此模型，你的整个程序就是由许多这样的依赖线组成，通常称之为流（flow），每条流都追踪一个值的特定实例的生存期。当有分支时，流可以分叉和合并，每个分叉都追踪该值的不同生存期。编译器可以检查你程序中的任何已知点，所有可以相互平行存在的流都是兼容的。例如，不能有两条并行的流对值进行可变访问。也不能有一条流借用一个值，但没有流拥有这个值。清单 2-2 展示了这两种情况。

```
let mut x;
// 该访问是非法的，因为没有流的起始点：
// assert_eq!(x, 42);
x = 42;   // （1）
// 这是合法的，可以从上面分配的值中画出流:
let y = &x;   // （2）
// 这就建立了第二条来自 x 的 可变的流:
x = 43;       // （3）
// 这将继续从y那里获得流，而y又从x那里获得流:
assert_eq!(*y, 42);   // （4）

// 清单 2-2：借用检查器将捕获的非法流
```
首先，在 x 被初始化之前，我们不能使用它，因为我们没有地方可以画流。只有当 x 被赋值时，才能从它那里开始画流。这段代码有两条流：一条从 （1） 到 （3） 的独占（&mut）流，以及一条从(1)到(2)再到(4)的共享（&）流。借用检查器检查每条流的每个顶点，并检查是否有其他不兼容的流同时存在。在这种情况下，当借用检查器检查(3)处独占流时，它会看到终止于(4)处的共享流。由于不能对一个值同时进行独占和共享，编译器（正确地）拒绝了该段代码。请注意，如果没有(4)，这段代码会编译的很好。共享流在(2)处终止，而当独占流在(3)处被检查时，不存在冲突的流。

如果一个新的变量与前一个变量同名，它们仍然被认为是不同的变量。后一个同名的变量被叫做“影子（shadow）变量”。这两个变量将共存，不过随后的代码无法再为前一个变量命名。该模型与实际编译器内部机制，特别是借用检查器大致吻合，所以使用它可以编写高效的代码。

### 底层模型

变量为内存位置命名，这种内存位置可能持有合法值，也可能没有。你可以把变量看作是一个“值槽”。当你给它赋值的时候，槽被填满，它的旧值（如果有的话）被析构和替换。当你访问它时，编译器会检查该槽是否为空，因为这意味着该变量未被初始化或其值已经被移动。指向变量的指针，指的是该变量的备用内存，并可以被解引用以获得其值。例如在语句 let x:usize 中，变量 x 是内存区域的名称，该区域可以容纳一个大小为 usize 的值，尽管它没有一个明确的值（它的槽是空的）。如果你给该变量赋值，比如x=6，那么该区域的内存就会容纳代表6这个值的比特位（bits）。这个模型与 C 和 C++ 以及其他许多底层语言所使用的内存模型相匹配，当你需要明确推理内存时，它是有用的。

>“注意：在此例子中，我们忽略了 CPU 寄存器，并将其视为一种优化。在现实中，如果一个变量不需要内存地址，编译器可能会使用一个寄存器为变量所用，而不是内存区域。

你可能会发现，其中一个和你之前的模型比较吻合，但我鼓励你尝试把两个模型都弄明白。它们都同样有效，并且都非常简洁，任何有用的心智模型都必须是简洁的。如果你能从两个维度来考虑一段代码，你会发现在处理复杂的代码段时要容易得多，并能理解为什么它们能或不能按你的期望进行编译和执行。

## 内存区域

既然你已经掌握了如何引用内存，那么现在我们需要讨论内存究竟是什么。内存有许多不同的区域，也许令人惊讶的是，并非所有区域都存储在计算机的 DRAM[3] 中。使用哪一部分内存对编写代码的方式有重大影响。用于编写 Rust 代码的三个最重要的区域是栈（stack）、堆（heap）和静态内存（static memory）。

### 栈

栈是一个内存段，用于程序中函数调用的暂存空间。每次调用函数时，都会在栈顶分配一个称为帧（frame）的连续内存块。靠近栈底部的是主函数的帧，当函数调用其他函数时，额外的帧被压入栈。函数的帧包含该函数中包含的所有变量，以及该函数接受的任何参数。当函数返回时，它的栈帧被回收。

构成函数局部变量的字节不会被立即清除，但是访问它们并不安全，因为它们可能已经被后续的与回收栈帧重叠的函数调用栈帧所覆盖了。即便它们没有被覆盖，也可能包含了非法使用的值，例如在函数返回时被移动的值。

栈帧，以及它们最终会消失的重要事实，与 Rust 中的生存期概念紧密相连。任何存储在栈帧中的变量在该帧消失后都不能被访问，所以对它的任何引用都必须有一个和不长于这个栈帧自身生存期的生存期。

### 堆

堆是一个内存池，与当前程序调用栈无关。在堆内存中的值会一直存在，直到它们被明确地释放。当你想让一个值超过当前函数栈帧的生存期时，这很有用。如果该值是函数的返回值，调用函数可以在其栈中留下一些空间，让被调用的函数在返回前将该值写入其中。但是，如果你想将该值发送给不同的线程，而当前线程可能根本不与之共享栈帧，那么你可以将其存储在堆上。

堆这个内存池足够大，你可以直接在其中分配连续的内存段。然后，你会得到一个指向该内存段起点的指针。此内存段将为你保留，直到你以后释放它。这个过程通常称之为 free，以 C 标准库中相应函数的名字命名。由于堆中分配的内存在函数返回时不会消失，所以你可以为某个值分配堆内存，并把它的指针传给另外一个线程，并让这个线程安全地进行值操作。或者，换个说法，当你用堆内存分配时，产生的指针拥有不受约束的生存期，意味着，它的生存期和你的程序运行时一样长。

Rust 中与堆交互的主要机制是 Box 类型。当你写 Box::new(value)时，该值被放到堆上，而你得到的结果（Box<T>）是堆上该值的一个指针。当 Box 最终被析构（Drop）时，该内存被释放。

如果你忘记释放堆内存，它会永远存在，而你的应用程序最终会吃掉机器上的所有内存。这就是所谓的内存泄露（memory leaking），通常这是你应该避免的事情。然而，在某些情况下，你会明确地想要泄漏内存。例如，假设你有一个全局只读配置，整个程序都可以访问。你可以在堆上分配它，然后用 Box::leak显式地泄漏它，以获得它的“静态引用”。

### 静态内存

静态内存其实是对位于已编译文件的几个密切相关区域的总称。当程序被执行时，这些区域会自动加载到内存中。静态内存中的值在程序整个执行过程中一直存在。程序的静态内存包含程序的二进制代码，通常被映射为只读。当程序执行时，它会走查文本段（text-segment）中二进制代码的每条指令，并在调用函数时跳转。静态内存还保存着你用静态关键字声明变量的内存，以及代码中的某些常量值，比如字符串。

专门的生存期'static，其命名就来自于静态内存区域，标志着一个引用只要静态内存还在，就一直有效。这就是指整个程序执行期。由于静态变量内存是在程序开始时就分配的，所以根据定义，对静态内存中的变量的引用是“静态的（'static）”，因为它在整个程序结束前都不会被释放。反之则不然。并不是 'static的引用就必须指向静态内存。但是这个名称是合适的：一旦你创建了具有静态生存期的引用，就程序的其他部分而言，它指向的任何内容都可能在静态内存中，因为无论程序希望使用它多久都可以。

在使用 Rust 时，你遇到 'static'生存期相比于遇到真正的静态内存（比如通过 static 关键字创建）要频繁得多。这是因为'static 经常出现在类型参数的 trait限定中。像 T: 'static 这样的限定表明，类型参数 T 能存活多久，就保留它多久，直到程序执行结束。从本质上讲，这种限定要求 T 是自有的（owned）和 自足的（self-sufficient），要么它不借用其他（非静态）的值，要么它所借用的任何东西也是静态的（ 'static）。作为限定的'static有一个很好的示例是std::thread::spoon函数，它用于创建一个新的线程，并要求传递给它的闭包是'static的。新的线程可能会比当前线程存活期更长（outlive），所以新线程不能引用存储在旧线程栈上的任何东西。新线程只能引用在整个生存期内存在的值，这可能是程序的剩余时间。

> “注意：你可能想知道 const 和 static 有什么区别。const关键字用于声明常量。常量项（Const Item）可以在编译时被完全计算出来，任何引用它们的代码在编译时都会被常量的计算值所取代。一个常量没有与之相关的内存或其他存储空间（它不是一个位置）。你可以把常量视为方便获取某个特定值的名称。

### 所有权（Ownership）

Rust 的内存模型的核心思想是，所有的值都有一个所有者（owner），也就是说，正好有一个位置（通常是一个作用域）负责最终释放每个值。这是通过借用检查器来执行的。如果值被移动了，比如把它赋值给一个新的变量、插入到新的动态数组（Vec）中，或把它放到堆上，值的所有权就会从旧的位置移动到新的位置。这时，你就不能再通过原来那个所有者变量来访问该值，即便构成该值的比特位事实上仍然存在。你必须通过引用其新位置的变量来访问被移动的值。

有些类型并不遵循这一规则。如果一个值的类型实现了特殊的 Copy 特质，哪怕它被重新赋值到新的内存位置，该值也不会被认为是已经移动。相反，该值已经被复制，新旧两个位置都可被访问。从本质来看，这种行为是在要移动的目的位置上构建了另一个值相同的实例。Rust 中大多数原生类型，比如整数和浮点类型，都是 复制（Copy）类型。要成为复制类型，必须能够做到简单地通过复制它们的比特位来复制该类型的值。这就排除了所有包含非复制类型的类型，以及任何拥有资源的类型。因为当值被析构时，它必须被释放。

要了解原因，请考虑如果像 Box 这样的类型如果被 复制会发生什么。如果我们执行 box2 = box1，那么 box1 和 box2 都会相信它们拥有分配给 box 的堆内存。当它们超出作用域之外，都会尝试释放堆内存。两次释放堆内存可能会导致灾难性后果。

当一个值的所有者不再使用它时，所有者有责任通过析构（Drop）它来对该值进行任何必要的清理。在 Rust 中，当保存值的变量不在作用域内时，会自动析构。类型通常会递归地析构它们包含的值，因此析构复杂类型的变量可能会导致析构很多值。由于 Rust 的所有权分立，所以不会发生意外多次析构相同值的情况。一个变量持有对另一个值的引用，并不表示拥有那个值，因此当这个变量被析构的时候，它引用的另一个值并不会同时析构。

清单 2-3 中的代码快速总结了有关所有权、移动和复制语义以及析构的规则。
```
let x1 = 42;
let y1 = Box::new(84);
{   // 开始一个新的作用域
    let z = (x1, y1); // (1)
    // z 出了此作用域就要被析构;
    // 它依次析构 x1 和 y1 中的值
}   // (2)
// x1 的值是 Copy 语义，所以它不会移动给 z
let x2 = x1; // (3)
// y1 的值不是 Copy 语义, 所以它会移动给 z
// let y2 = y1;  // (4)

// 清单2-3: 移动和复制语义
```
> “析构顺序
当值超出作用域时， Rust 会自动析构它们，比如清单 2-3 中内部作用域的 x1 和 x2 。析构顺序的规则相当简单：变量（包括函数参数）按相反的顺序析构，嵌套值按源代码的顺序析构。
这看上去很奇怪，为什么会有这样的差异？但如果我们仔细思考，就会发现这很有道理。假设你写了一个函数，声明了一个字符串，然后将该字符串的引用插入到一个新的哈希表中。当函数返回时，哈希表必须先被析构。如果字符串先被析构，那么哈希表就会持有一个无效引用。一般来说，后来的变量可能包含对早期值的引用，而由于 Rust 的生存期规则，反过来就不会发生这个问题。出于这种原因，Rust 以相反的顺序析构变量。
现在来反向析构嵌套的值，比如元组、数组或结构体中的值。但这可能会让用户感到惊讶。如果你构建了一个包含两个值的数组，如果数组的最后一个元素先被析构，那会显得非常奇怪。这同样适用于元组和结构体，最直观的行为是第一个元组元素或字段先被析构，然后是第二个，以此类推。与变量不同，在这种情况下没有必要颠倒析构顺序，因为 Rust 目前不允许在单个值中进行自引用（self-reference）。所以， Rust 使用了符合直觉的选择。
这段代码一开始有两个值，数字 42 和一个包含数字 84 的 Box 类型（在堆上存储）。前者是 复制语义，而后者不是。当我们把 x1 和 y1 放到元组中时，x1 是被复制给 z，而 y1则被移动给 z。此时 x1 依然可以被访问，可以在 (3)处被再次使用。另一方面，一旦在(4)处的 y1 的值被移动，它就变得不可被访问了，任何访问它的尝试都会引起编译器错误。当 z 超出(2)处的作用域时，它所包含的元组值会被析构，这意味着会析构从x1复制的值和从y1移动的值。当 y1 的 Box 被析构时，它会释放用于存储 y1 值的堆内存。

### 借用（Borrowing）和生存期 (Lifetimes)

Rust 允许一个值的所有者将该值的引用借出去而不会放弃自己的所有权。引用是一个指针，它携带了自身该如何被使用的附加契约，例如，引用是否提供对被引用值的独占访问，或者被引用值是否也可以有其他引用指向它。

### 共享引用

一个共享引用，&T，顾名思义是一个可以共享的指针。包含了指向同一个值的任意数量的其他引用，每个共享引用都是复制类型，所以你可以轻易地制造更多的引用。共享引用后面的值是不可变的。你不能修改或重新分配共享引用指向的值，也不能把共享引用强制转换为可变的值。

Rust 编译器会假设共享引用所指向的值在该引用存在期间不会改变。例如，如果 Rust 编译器看到一个共享引用背后的值在一个函数中被多次读取，那么它有权利只读取一次并重复使用该值。具体而言，清单2-4中的断言不应该失败。

```
fn cache(input: &i32, sum: &mut i32) {
   *sum = *input + *input;
   assert_eq!(*sum, 2 * *input);
}
// 清单2-4 ：Rust 假设共享引用是不可变的
```
这基本和编译器是否选择应用某个特定的优化无关。由编译器启发式（compiler heuristics）会随着时间的推移而改变，所以应该针对编译器允许做的事情来编码，而不是在某个特定的时间点上，在特定的情况下实际做什么。
> “译注：编译器启发式（compiler heuristics）是指当今编译器使用硬编码的启发式方法来决定何时，是否以及仅应用有限的一组优化中的哪一项。

### 可变引用
共享引用的替代方案是可变引用：&mut T。对于可变引用，Rust 编译器又被允许充分利用引用所携带的契约：编译器假设没有其他线程访问的目标值，无论是通过共享引用还是可变引用。换句话说，编译器假设可变引用是独占的。这使得一些有趣的优化成为了可能，这些优化在其他语言中不容易实现。以清单 2-5 中代码为例。
```
fn noalias(input: &i32, output: &mut i32) {
    if *input == 1 {
        *output = 2; // (1)
    } if *input != 1 {  // (2)
        *output = 3;
    }
}

// 清单2-5:  Rust 假设可变借用是独占的
```
在 Rust 中，编译器可以假设输入和输出不指向同一内存。因此， 在(1)处输出的重新分配不能影响(2)处的检查，整个函数可以编译成一个 if-else块（block）。如果编译器不能依赖可变性契约，这种优化就会失效，因为在 noalias(&x, &mut x) 这种情况下， (1)处的输入可能会导致输出 3。

一个可以改变的引用只允许你改变该引用所指向的内存位置。你是否可以改变直接引用之外的值，取决于位于两者之间的类型所提供的方法。通过清单2-6示例更容易理解。
```
let x = 42;
let mut y = &x; // y &i32 类型
let z = &mut y; // z 是 &mut &i32 类型
// 清单 2-6: 可变性只适用于直接引用的内存

```
在此例中，你可以通过使指针 y 引用不同的变量来改变它的值（也就是不同的指针）。但你不能改变所指向的值（即 x 的值）。同样，你可以通过z来改变y的指针值，但你不能改变 z 自身，使其指向一个不同的值。

拥有一个值和拥有一个可变的引用之间的区别主要是，所有者负责在不需要时析构该值。除此之外，你可以通过一个可变引用做任何事情。如果你拥有这个值的话，有一点需要注意：如果你把这个值移到可变引用之后，那么你必须在它的位置上留下另一个值。原因很简单，如果你不这样做，所有者仍然会认为它需要析构这个值，但是那里已经没有供它析构的值了。

清单 2-7 给出一个例子，说明你可以通过哪些方式来移动一个可变引用后面的值。
```
fn replace_with_84(s: &mut Box<i32>) {
    // 这是不可能的，因为 *s 会变成空值 :
    // let was = *s; // (1)
    // 但是这可以:
    let was = std::mem::take(s); // (2)
    // 这也可以:
    *s = was; // (3)
    // 可以在 &mut 后面交换值:
    let mut r = Box::new(84);
    std::mem::swap(s, &mut r); // (4)
    assert_ne!(*r, 84);
}

let mut s = Box::new(42);
replace_with_84(&mut s);
// 5

// 清单 2-7：可变性仅适用于直接引用的内存。
```
上面代码中被注释的行表示非法操作。在(1)处你不能简单地将值移出，因为调用者仍然会认为它拥有这个值，并且会在(5)处再次释放它，导致双重释放（double free）。如果你只是想留下一些有效的值，在 (2)处的std::mem::take 是一个不错的选择。它等同于 std::mem::replace(&mut value, Default::default()) ，它将值从可变引用后移出，但是为该类型留下一个新的默认值。默认值是一个单独的、自有的值，所以当作用域在(5)处结束时，调用者可以安全地析构它。

另外，如果你不需要引用后面的旧值，可以用一个已经拥有的值来覆盖它（如(3)处），将它留给调用者来析构此值。当这么做的时候，可变引用后面的旧值会被立即析构。

最后，如果存在两个可变引用，那么可以在不拥有其中任何一个的情况下交换它们的值（如(4)处）。因为两个引用最后都会有一个合法持有的值，供它们的所有者最终释放。


### 内部可变性

一些类型提供了内部可变性，这意味着它们允许你通过共享引用来改变一个值。这些类型通常依靠额外的机制（如原子CPU指令）或不变性来提供安全的可变性，而不依赖排他性引用的语义。这些通常分为两类：一类是让你通过共享引用获得一个可变的引用，另一类是让你替换一个只给定共享引用的值。

第一类由Mutex和RefCell等类型组成，它们包含安全机制，以确保对于它们给出的任何值的可变引用，在同一时间只能有一个可变引用（没有共享引用）。在这个机制下，这些类型（以及那些类似的类型）都依赖于一个叫做UnsafeCell的类型，它的名字应该立即让你对使用它感到犹豫。我们将在第9章详细介绍UnsafeCell，但现在你应该知道它是通过共享引用进行变异的唯一正确方法。

其他类别中提供内部可变性的类型，是那些不给出内部值的可变引用，而只是给你提供操作该值的方法的类型。std::sync::atomic中的原子整数类型和std::cell::Cell类型就属于这个类别。你不能直接获得对这种类型背后的usize或i32的引用，但你可以在一个给定的时间点上读取和替换它的值。

>标准库中的Cell类型是一个有趣的例子，它通过不变性实现了安全的内部可变性。它不能跨线程共享，也不会给出对Cell中所包含的值的引用。相反，所有的方法要么完全替换该值，要么返回所含值的一个副本。因为没有对内部值的引用存在，所以移动它总是可以的。而且，由于Cell不能跨线程共享，即使变化是通过共享引用发生的，内部值也不会被并发变异。

### 生命周期

如果你正在读这本书，你可能已经熟悉了生命期的概念，可能是通过编译器对生命期规则违反的反复通知。这种程度的理解将有助于你的大部分代码，但是当我们深入到Rust的更复杂的部分时，你将需要一个更严格的心理模型来工作。

新的Rust开发者经常被教导要把生命周期看成是与作用域相对应的：当你获取某个变量的引用时，一个生命周期就开始了，当这个变量被移动或超出作用域时，生命周期就结束。这通常是正确的，而且通常是有用的，但实际情况要复杂一些。生命期实际上是一个代码区域的名称，一些引用必须在该区域内有效。虽然生命期经常与作用域重合，但并不是必须如此，我们将在本节后面看到。

#### 生命周期和借用检查器

Rust生命期的核心是借用检查器。每当一个具有生命周期'a的引用被使用时，借用检查器就会检查'a是否仍然活着。它通过追踪路径回到'a开始的地方--即引用被使用的地方--从使用的那一刻开始，并检查该路径上是否有任何冲突的使用。这确保了引用始终指向一个可以安全访问的值。这类似于我们在本章前面讨论的高级 "数据流 "心理模型；编译器检查我们正在访问的引用的流与任何其他并行流不冲突。

清单2-8显示了一个简单的代码例子，其中有对x的引用的生命周期注释。
```
let mut x = Box::new(42);
1 let r = &x; // 'a
if rand() > 0.5 {
2 *x = 84;
} else {
3 println!("{}", r); // 'a 
}
```
生命周期在1处，我们引用x时开始。在第一个分支2中，我们立即尝试修改x，把它的值改为84，这个操作需要一个&mut x。借用检查器取出一个对x的可变引用并立刻检查其使用情况。它发现在获取引用和使用之间没有冲突，所以它会接受这个代码。如果你习惯于把生命周期看作是作用域，这可能会让你感到惊讶，因为r在2的时候仍然在作用域内（在4的时候超出了作用域）。但是借用检查器足够智能，能够意识到如果采纳这个分支，r在后续将不会再被使用，因此在这里对x进行可变访问是没问题的。或者，换句话说，在1处创建的生命周期没有延伸到这个分支：在2处没有来自r的流，因此就不会有冲突流。借用检查器在3处发现了print语句对于r的使用。它沿着路径回到1，发现没有冲突使用（2不在路径上），所以它也接受了这个使用。

如果我们在清单1-8的4中添加另一个对r的使用，代码将不会再编译成功。生命周期'a将会从1持续整条路径直到4（对r的最后一次使用），并且当借用检查器检查我们对r新增的使用时，它会发现在2处使用上的冲突。

生命周期可以变得相当复杂。在清单2-9你可以看到一个有漏洞的生命周期的例子，它在开始和最终结束的地方间歇性地失效。

```
let mut x = Box::new(42);
1 let mut z = &x;
for i in 0..100 {
2 println!("{}", z); 
3 x = Box::new(i);
4 z = &x;
}
println!("{}", z);
// 'a
```

生命周期在1处，我们获取一个对x的引用时开始。当我们在3中对x进行move时，生命周期'a结束了，因为它不再有效。借用检查器通过考虑'a在2处结束，这使得x在3处没有冲突流，从而接受这个move。然后，我们通过在4处更新了z的引用重启了生命周期。不管代码现在循环回到2还是继续到最后的print语句，这两种用法的流都具有有效值，且没有冲突的流，因此借用检查器接受了代码！

同样，这与我们之前讨论的内存的数据流模型完全一致。当x被移动时，z停止存在。当我们稍后重新分配z时，我们创建了一个全新的变量，这个变量只从这一点开始存在。碰巧的是，这个新变量也被命名为z。

>借用检查器是保守的。如果它不确定一个借用是否有效，它就会拒绝它，因为允许一个无效的借用的后果可能是很糟糕的。借用检查器越来越聪明，但有时它也需要帮助来理解为什么一个借用是合法的。这就是为什么我们有不安全的Rust的部分原因

#### 泛型生命周期

偶尔你需要在你自己的类型中存储引用。这些引用需要有一个生命周期，这样当它们被用于该类型的各种方法时，借用检查器可以检查它们的有效性。如果你想让你的类型上的一个方法返回一个比对自己的引用更久远的引用，那就更是如此了。

Rust允许你在一个或是多个生命周期上定义一个泛型，就像它允许你定义类型的泛型一样。teve Klabnik和Carol Nichols的《Rust编程语言》（No Starch Press，2018）对这一主题做了一些详细介绍，所以我不会在这里重申基础知识。但是，当你编写这种性质的更复杂的类型时，围绕这种类型和生命期之间的互动有两个微妙的问题，你应该注意到。

首先，如果你的类型也实现了Drop，那么Drop你的类型也算作是对你的类型的任何生命期或泛型的使用。基本上，当你的类型的一个实例被drop时，借用检查器将检查在drop时，它对你的类型的任意泛型生命周期使用是否仍然合法。这是必要的，以防你的drop代码确实使用了任何这些引用。如果你的类型没有实现 Drop，drop这个类型就不算是使用，用户只要不再使用你的类型，就可以自由地忽略存储在你的类型中的任何引用，就像我们在清单 1-7 中看到的那样。我们将在第9章中更多地讨论这些关于drop的规则。

其次，虽然一个类型可以有多个泛型生命周期，但如此频繁地使用它只会不必要地使类型签名复杂化。通常，一个类型有一个泛型生命周期就可以了，编译器将对插入到类型中的任何引用使用较短的生命周期作为该生命周期。如果您有一个包含多个引用的类型，并且它的方法返回的引用应该只绑定到其中一个引用的生命周期，那么您应该只使用多个泛型生命周期参数。

考虑清单1-10中的类型，它为你提供了一个由特定的其他字符串分隔的字符串部分的迭代器。

```
struct StrSplit<'s, 'p> {
  delimiter: &'p str,
  document: &'s str,
}
impl<'s, 'p> Iterator for StrSplit<'s, 'p> {
  type Item = &'s str;
  fn next(&self) -> Option<Self::Item> {
todo!() }
}
fn str_before(s: &str, c: char) -> Option<&str> {
  StrSplit { document: s, delimiter: &c.to_string() }.next()
}
```

当你构建这个类型时，你必须给出分隔符和要搜索的文件，这两个都是对字符串值的引用。当你请求下一个字符串时，你会得到一个对文件的引用。考虑一下如果你在这种类型中使用单一的生命周期会发生什么。迭代器产生的值将与文档的生命周期和分隔符相联系。这将使str_before无法编写：返回类型将有一个与函数本地变量相关的生命周期--to_string产生的String--借用检查器将拒绝该代码。


#### 生命周期变更

变异是程序员经常接触到的一个概念，但很少知道它的名字，因为它大多是不可见的。简而言之，变异描述了哪些类型是其他类型的子类型，以及什么时候可以用子类型来代替超类型（反之亦然）。广义上讲，如果一个类型A至少和B一样有用，那么它就是另一个类型B的子类型。变异，就是为什么在Java中，如果Turtle是Animal的子类型，你可以把Turtle传给接受Animal的函数，或者在Rust中，你可以把&'static str传给接受&'a str的函数。

虽然变异通常隐藏在视线之外，但它经常出现，我们需要对它有一个工作机制上的了解。Turtle是Animal的一个子类型，因为Turtle比某些未指定的Animal更 "有用"--Turtle可以做任何动物能做的事情，而且可能更多。同样，'static是'a的一个子类型，因为 'static的生命周期至少与任何 'a一样长，所以更有用。或者，更一般地说，如果'b：'a（'b比'a长寿），那么'b是'a的一个子类型。这显然不是正式的定义，但是它已经足够接近实际用途了。

所有类型都有一个变异，它定义了哪些其他类似的类型可以用于该类型的位置。有三种变异：协变、不变、和逆变。如果你可以只使用一个子类型来代替该类型，那么该类型就是协变的。例如，如果一个变量是&'a T类型，你可以给它提供一个&'static T类型的值，因为&'a T在'a中是协变的。&'a T在T中也是协变的，所以你可以把一个&Vec<&'static str>传递给一个接受&Vec<&'a str>的函数。

有些类型是不变的，这意味着你必须准确提供给定的类型。&mut T就是一个例子--如果一个函数接受一个&mut Vec<&'a str>，你不能把一个&mut Vec<&'static str>传递给它。也就是说，&mut T在T中是不变的。如果你可以，函数可以在Vec中放入一个短暂存活的字符串，然后调用者会继续使用它，认为它是一个Vec<&'static str>，从而认为包含的字符串是 'static。任何提供可变性的类型一般都是不变的，原因也是如此--例如，Cell<T>在T中是不变的。

最后一类，即逆变，出现在函数参数上。如果函数类型可以接受其参数不那么有用，那么它们就会更有用。如果你把参数类型本身的变异与它们作为函数参数时的变异进行对比，这一点就更清楚了：

```
  let x: &'static str; // more useful, lives longer
  let x: &'a      str; // less useful, lives shorter
  fn take_func1(&'static str) // stricter, so less useful
  fn take_func2(&'a str)      // less strict, more useful
```
这种翻转的关系表明，Fn(T)在T中是逆变的。  
那么，当涉及到生命周期时，为什么你需要学习变异？当你考虑泛型生命周期参数如何与借用检查器交互时，变异就变得很重要。考虑一下像清单1-11中所示的类型，它在一个字段中使用多个生命周期。
```
struct MutStr<'a, 'b> {
    s: &'a mut &'b str
}
let mut s = "hello";
1 *MutStr { s: &mut s }.s = "world";
  println!("{}", s);
```
乍一看，在这里使用两个生命期似乎没有必要--我们没有需要区分结构中不同部分的借用的方法，就像我们在清单1-10中对StrSplit所做的那样。但是如果你用一个'a'来代替这里的两个生命期，代码就不再能编译了！而这一切都是因为变异。

>1处的语法可能看起来很陌生。它相当于定义了一个变量x，持有 一个MutStr，然后写*x.s = "world"，只是没有变量，所以MutStr被立即删除。

在1处，编译器必须确定生命周期参数应该被设置的寿命。如果有两个生命周期，'a被设置为有待确定的s的借用的生命期，'b被设置为'static，因为那是提供的字符串 "hello "的生命期。如果只有一个生命期'a，编译器会推断该生命期必须是'static。

当我们后来试图通过共享引用访问字符串引用s来打印它时，编译器试图缩短MutStr使用的s的可变借用，以允许s的共享借用。

在这个双生命周期的case中，'a简单地在println之前结束，'b保持不变。在单生命周期的case中，我们遇到了问题。编译器想要缩短s的借用，但是要做到这一点，它也必须缩短str的借用。虽然&'static str可以被缩短成为任意的&'a str（&'a T是'a的一个协变），但在这里它在&mut T后面，&mut T在T中是不变的。不变性要求相关的类型永远不会被子类或是超类所取代，所以编译器试图缩短借用时间的努力失败了，它报告说这个列表仍然是可变的借用。

由于不变性带来的灵活性降低，你要确保你的类型在尽可能多的泛型参数上保持协变性（或是在合适的地方保持逆变）。如果这需要引入额外的生命周期参数，你需要仔细权衡添加另一个参数的人之成本与不变性的工程成本。

### 总结
本章的目的是建立一个坚实的、共同的基础，以便我们在接下来的章节中继续发展。到目前为止，我希望你已经牢牢掌握了Rust的内存和所有权模型，并且你可能从借用检查器中得到的那些错误看起来不那么神秘了。你可能已经知道了我们在这里所涉及的一些细节，但希望这一章能让你更全面地了解这些内容是如何结合在一起的。在下一章中，我们将对类型进行类似的处理。我们将讨论类型是如何在内存中表示的，看看泛型和特征是如何产生运行代码的，并看看Rust为更高级的用例提供的一些特殊类型和特征构造。