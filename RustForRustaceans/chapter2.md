# 类型系统

既然基础知识已经讲完了，我们就来看看 Rust 的类型系统。我们将跳过 The Rust Programming Language 中涵盖的基础知识，而是开始对类型系统进行深入研究。在本章节会分别介绍不同类型在内存中的布局方式、特征和特征边界的来龙去脉、存在类型以及跨 crate 边界使用类型的规则。

## 什么是类型系统
[编程语言中的类型系统](https://zhuanlan.zhihu.com/p/434668264)
[类型系统相关的书籍](https://www.zhihu.com/question/22416404/answer/23653747)

## 类型在内存中的布局

每个 Rust 值都有一个类型。 正如我们将在本章中看到的，类型在 Rust 中有多种用途，但它们最基本的作用之一是告诉您如何解释内存位。 例如，位序列 0b10111101（以十六进制表示法写为 0xBD）在您为其分配类型之前本身并没有任何意义。当在类型 u8 下解释时，该位序列是数字 189。在类型 i8 下解释时，它是 –67。当您定义自己的类型时，编译器的工作是确定已定义类型的每个部分在该类型的内存表示中的位置。您的结构的每个字段出现在位序列中的什么位置？ 您的枚举的判别式存储在哪里？ 当您开始编写更高级的 Rust 代码时，了解此过程的工作原理很重要，因为这些细节会影响代码的正确性和性能。

### 对齐

在我们讨论如何确定一个类型在内存中的表示之前，我们首先需要讨论对齐的概念，它规定了一个类型的字节可以存储在哪里。 一旦确定了类型的表示，您可能会认为可以获取任意内存位置并将存储在那里的字节解释为该类型。 虽然这在理论上是正确的，但在实践中，硬件也会限制给定类型的放置位置。 最明显的例子是指针指向字节，而不是位。 如果您将类型 T 的值放在计算机内存的第 4 位开始，您将无法引用它的位置； 您可以创建一个仅指向字节 0 或字节 1（位 8）的指针。 因此，所有值，无论其类型如何，都必须从字节边界开始。 我们说所有的值都必须至少是字节对齐的——它们必须被放置在一个 8 位的倍数的地址上。
有些值具有比字节对齐更严格的对齐规则。 在 CPU 和内存系统中，内存通常以大于单个字节的块进行访问。 例如，在 64 位 CPU 上，大多数值都以 8 字节（64 位）的块为单位进行访问，每个操作都从 8 字节对齐的地址开始。 这称为 CPU 的字长。 然后 CPU 使用一些技巧来处理读取和写入较小的值，或者跨越这些块边界的值。
在可能的情况下，您希望确保硬件能够以其“本机”对齐方式运行。 要了解原因，请考虑如果您尝试读取从 8 字节块的中间开始的 i64 会发生什么（也就是说，指向它的指针不是 8 字节对齐的）。 硬件必须进行两次读取——一次从第一个块的后半部分读取到 i64 的开始，一次从第二块的前半部分读取 i64 的其余部分——然后拼接 结果在一起。 这不是很有效。 由于该操作分布在对底层内存的多次访问中，如果您正在读取的内存由不同的线程同时写入，您也可能会得到奇怪的结果。 您可能会在另一个线程的写入发生之前读取前 4 个字节，然后再读取第二个 4 个字节，从而导致值损坏。
对未对齐数据的操作称为未对齐访问，可能导致性能不佳和并发问题。 出于这个原因，许多 CPU 操作要求或强烈希望它们的参数自然对齐。 自然对齐的值是其对齐与其大小相匹配的值。 因此，例如，对于 8 字节加载，提供的地址需要 8 字节对齐。
由于对齐访问通常更快并且提供更强的一致性语义，因此编译器会尽可能地利用它们。 它通过为每种类型提供一个对齐方式来实现这一点，该对齐方式是根据它包含的类型计算的。 内置值通常与其大小对齐，因此 u8 是字节对齐的，u16 是 2 字节对齐的，u32 是 4 字节对齐的，u64 是 8 字节对齐的。 复杂类型——包含其他类型的类型——通常分配给它们包含的任何类型的最大对齐。 例如，包含 u8、u16 和 u32 的类型将因为 u32 而进行 4 字节对齐。


### 布局
现在您了解了对齐，我们可以探索编译器如何决定类型的内存中表示形式，称为布局。
默认情况下，正如您很快就会看到的，Rust 编译器很少保证它如何布局类型，这使得理解底层原理的起点很差。 幸运的是，Rust 提供了一个 repr 属性，您可以将其添加到类型定义中以请求该类型的特定内存中表示。 最常见的是 repr(C)，如果您看到的话。 顾名思义，它以与 C 或 C++ 编译器布局相同类型的方式兼容的方式布局类型。 这在编写使用外部函数接口与其他语言交互的 Rust 代码时很有帮助，我们将在第 11 章中讨论，因为 Rust 将生成符合其他语言编译器预期的布局。 由于 C 布局是可预测的并且不会发生变化，如果您正在使用原始指针进入类型，或者如果您需要在您知道具有相同的两种不同类型之间进行转换，则 repr(C) 在不安全的上下文中也很有用 领域。 当然，它非常适合我们迈出布局算法的第一步。

> 另一个有用的表示是 repr(transparent)，它只能用于具有单个字段的类型，并保证外部类型的布局与内部类型的布局完全相同。 这与“newtype”模式结合使用会很方便，在这种模式下，您可能希望对某些 struct A 和 struct NewA(A) 的内存表示进行操作，就好像它们是相同的一样。 没有 repr(transparent)，Rust 编译器不保证它们会有相同的布局。

那么，让我们看看编译器如何使用 repr(C) 布局特定类型：清单 2-1 中的 Foo 类型。 您认为编译器会如何将其放置在内存中？
```
#[repr(C)]
struct Foo {
  tiny: bool,
  normal: u32,
  small: u8,
  long: u64,
  short: u16,
}
```

首先，编译器看到字段 tiny，其逻辑大小为 1 位（真或假）。 但是由于 CPU 和内存以字节为单位运行，因此在内存中表示中 tiny 被赋予 1 个字节。 接下来，normal 是一个 4 字节类型，所以我们希望它是 4 字节对齐的。 但是即使 Foo 是对齐的，我们分配给 tiny 的 1 个字节也会使 normal 无法对齐。 为了纠正这个问题，编译器将 3 个字节的填充（具有不确定值的字节在用户代码中被忽略）插入到 tiny 和 normal 之间的内存表示中。 没有值进入填充，但它确实占用空间。
对于下一个字段，small，对齐很简单：它是一个 1 字节的值，并且
结构中的当前字节偏移量是 1 + 3 + 4 = 8。这已经是字节对齐的，所以 small 可以在 normal 之后立即移动。 但是，随着 long 我们又遇到了问题。 我们现在有 1 + 3 + 4 + 1 = 9 个字节到 Foo。 如果 Foo 是对齐的，那么 long 就不是我们想要的 8 字节对齐方式，所以我们必须插入另外 7 个字节的填充以使 long 再次对齐。 这也方便地确保了我们需要的最后一个字段 short 的 2 字节对齐，使总数达到 26 字节。 现在我们已经遍历了所有字段，我们还需要确定 Foo 本身的对齐方式。 这里的规则是使用 Foo 的任何字段的最大对齐方式，由于长，它将是 8 个字节。 因此，为了确保 Foo 保持对齐（如果放置在一个数组中），编译器然后添加最后 6 个字节的填充以使 Foo 的大小是其 32 字节对齐的倍数。
现在我们准备摆脱 C 的遗留问题，并考虑如果我们不使用清单 2-1 中的 repr(C) 布局会发生什么。 C 表示的主要限制之一是它要求我们按照它们在原始结构定义中出现的相同顺序放置所有字段。 默认的 Rust 表示 repr(Rust) 消除了该限制，以及一些其他较小的限制，例如碰巧具有相同字段的类型的确定性字段排序。 也就是说，即使是共享所有相同字段、相同类型、相同顺序的两种不同类型，在使用默认 Rust 布局时也不能保证布局相同！
由于我们现在可以对字段重新排序，因此我们可以将它们
按大小递减顺序排列。 这意味着我们不再需要 Foo 字段之间的填充； 字段本身用于实现必要的对齐！ Foo 现在只是其字段的大小：只有 16 个字节。 这就是为什么 Rust 在默认情况下不对类型在内存中的布局提供很多保证的原因之一：通过给编译器更多的余地来重新排列事物，我们可以生成更高效的代码。
事实证明，还有第三种布局类型的方法，那就是告诉编译器我们不希望字段之间有任何填充。 在这样做时，我们表示我们愿意承担使用未对齐访问的性能损失。 最常见的用例是当可以感受到每个额外内存字节的影响时，例如，如果您有很多该类型的实例，如果您的内存非常有限，或者如果您正在发送 - 低带宽介质（如网络连接）上的内存表示。 要选择加入此行为，您可以使用 #[repr(packed)] 注释您的类型。 请记住，这可能会导致代码变慢，在极端情况下，如果您尝试执行 CPU 仅支持对齐参数的操作，这可能会导致程序崩溃。
有时，您希望为特定字段或类型提供比技术要求更大的对齐方式。 您可以使用属性#[repr(align(n))] 来做到这一点。 一个常见的用例是确保连续存储在内存中的不同值（如数组）最终位于 CPU 的不同缓存行中。 这样，您就可以避免虚假共享，这会导致并发程序的性能大幅下降。 当两个不同的 CPU 访问不同的值时会发生错误共享
共享缓存行； 虽然理论上它们可以并行操作，但它们最终都争相更新缓存中的同一个条目。 我们将在第 10 章更详细地讨论并发。

### 复杂类型

您可能对编译器如何在内存中表示其他 Rust 类型感到好奇。 这是一个快速参考：
元组：表示为一个结构，其字段类型与元组值的顺序相同。
数组：表示为包含类型的连续序列，元素之间没有填充。
为每个变体独立选择联合布局，对齐是所有变体中的最大值。
枚举 与 union 相同，但有一个额外的隐藏共享字段，用于存储枚举变体判别式。 判别式是代码用来确定给定值持有哪些枚举变体的值。 判别字段的大小取决于变体的数量。


### 动态大小类型和宽指针

您可能遇到过 trait Sized 标记特征在各种各样的Rust 文档和错误消息中。 通常，它出现是因为编译器希望您提供一个 Sized 类型，但您（显然）没有提供。 Rust 中的大多数类型会自动实现 Sized——也就是说，它们的大小在编译时是已知的——但有两种常见类型不会：特征对象和切片。 例如，如果您有一个 dyn Iterator 或 [u8]，则它们的大小没有明确定义。 它们的大小取决于一些信息，这些信息只有在程序运行时才知道，而不是在编译时，这就是它们被称为动态大小类型 (DST) 的原因。 没有人提前知道您的函数收到的动态迭代器是这个 200 字节的结构还是那个 8 字节的结构。 这就带来了一个问题：编译器通常必须知道某些东西的大小才能生成有效的代码，例如要分配多少空间给类型为 (i32, dyn Iterator, [u8], i32) 的元组或使用什么偏移量 如果您的代码试图访问第四个字段。 但如果类型不是 Sized，则该信息不可用。
编译器几乎在所有地方都要求类型是 Sized 的。 结构字段、函数参数、返回值、变量类型和数组类型都必须是 Sized 的。 这种限制非常普遍，以至于您编写的每个类型绑定都包含 T: Sized 除非您使用 T: ?Sized 明确选择退出它（? 表示“可能不是”）。 但如果你有一个 DST 并想用它做点什么，这就没什么用了，比如你真的想让你的函数接受一个特征对象或一个切片作为参数。
弥合未确定大小类型和已确定大小类型之间差距的方法是将未确定大小类型放在宽指针（也称为胖指针）后面。 宽指针就像一个普通指针，但它包含一个额外的字大小字段，该字段提供有关该指针的附加信息，编译器需要这些信息来生成合理的代码来处理该指针。 当您引用 DST 时，编译器会自动为您构造一个宽指针。 对于切片，额外信息只是切片的长度。 对于特征对象——好吧，我们稍后再谈。 至关重要的是，那个宽指针是 Sized 的。 具体来说，它是一个 usize（目标平台上一个单词的大小）大小的两倍：一个 usize 用于保存指针，另一个 usize 用于保存“完成”类型所需的额外信息。

## trait和trait的边界

Traits 是 Rust 类型系统的关键部分——它们是允许类型互操作的粘合剂，即使它们在定义时彼此不了解。 Rust 编程语言在涵盖如何定义和使用特征方面做得很好，所以我不会在这里讨论。 相反，我们将看看 traits 的一些更技术性的方面：它们是如何实现的、必须遵守的限制，以及 traits 的一些更深奥的用途。

### 编译和分发

到目前为止，您可能已经用 Rust 编写了大量的通用代码。 您已经在类型和方法上使用了泛型类型参数，甚至可能在各处使用了一些 trait bounds。 但是你有没有想过编译泛型代码时究竟发生了什么，或者当你在 dyn Trait 上调用 trait 方法时会发生什么？
当你在 T 上编写泛型类型或函数时，你实际上是在告诉编译器为每种类型制作该类型或函数的副本 T. 当您构造 Vec<i32> 或 HashMap<String, bool> 时，编译器实质上是复制粘贴泛型类型及其所有实现块，并将每个泛型参数的所有实例替换为您提供的具体类型。 它制作 Vec 类型的完整副本，每个 T 替换为 i32，并制作 HashMap 类型的完整副本，每个 K 替换为 String，每个 V 替换为 bool。
> 实际上，编译器实际上并没有进行完整的复制粘贴。 它只复制你使用的部分代码，所以如果你从不在 Vec<i32> 上调用 find，find 的代码将不会被复制和编译。

同样的事情也适用于泛型函数。 考虑清单 2-2 中的代码，它显示了一个泛型方法。
```
impl String {
  pub fn contains(&self, p: impl Pattern) -> bool {
    p.is_contained_in(self)
  }
}
```

为每个不同的模式类型制作此方法的副本（回想一下 impl Trait 是 <T: Trait> 的简写）。 我们需要为每个 impl Pattern 类型提供不同的函数体副本，因为我们需要知道 is_contained_in 函数的地址才能调用它。 需要告诉 CPU 跳转到哪里继续执行。 对于任何给定的模式，编译器知道该地址是该模式类型实现该特征方法的地址。 但是没有一个地址可以用于任何类型，所以我们需要为每种类型准备一个副本，每个副本都有自己的跳转地址。 这被称为静态分派，因为对于方法的任何给定副本，我们“分派到”的地址是静态已知的。

> 您可能已经注意到，在这种情况下，“静态”一词有点过载。 静态通常用来指代任何在编译时已知的东西，或者可以被视为已知的东西，因为它可以被写入静态内存，正如我们在第 1 章中讨论的那样。

这个从通用类型到许多非通用类型的过程
被称为单态化，这是通用 Rust 代码通常与非通用代码执行得一样好的部分原因。 当编译器开始优化你的代码时，就好像根本没有泛型一样！ 每个实例都单独优化，并使用所有已知类型。 作为
结果，代码就像直接调用传入模式的 is_contained_in 方法一样高效，没有任何特征。 编译器完全了解所涉及的类型，如果愿意，甚至可以内联 is_contained_in 的实现。
单态化也是有代价的：你的类型的所有这些实例都需要单独编译，如果编译器不能优化它们，这会增加编译时间。 每个单态函数也会产生自己的机器代码块，这会使您的程序更大。 而且由于指令不在泛型方法的不同实例之间共享，CPU 的指令缓存也不太有效，因为它现在需要有效地保存相同指令的多个副本。

> 通常，泛型方法中的大部分代码都不是类型相关的。 例如，考虑 HashMap::insert 的实现。 计算提供的键的哈希值的代码取决于地图的键类型，但遍历地图的桶以找到插入点的代码可能不一样。 在这种情况下，跨单态化共享方法的非泛型部分生成的机器代码会更有效，并且只在实际需要的地方生成不同的副本。
可用于此类情况的一种模式是在执行共享操作的泛型方法内声明一个非泛型辅助函数。 这只留下类型相关的代码供编译器为您复制粘贴，同时允许共享辅助函数。
使该函数成为内部函数还有一个额外的好处，即您不会用单一用途的函数污染您的模块。 您可以改为在方法外声明这样的辅助函数； 请注意不要将其作为通用 impl 块下的方法，因为那样它仍将是单态的。

静态分派的替代方法是动态分派，它使
在不知道该类型是什么的情况下调用泛型类型的特征方法的代码。 我之前说过，我们需要清单 2-2 中方法的多个实例的原因是，否则您的程序将不知道要跳转到哪个地址才能在给定模式上调用特征方法 is_contained_in。 好吧，通过动态调度，调用者只是告诉你。 如果将 impl Pattern 替换为 &dyn Pattern，则告诉调用者他们必须为此参数提供两条信息：模式的地址和 is_contained_in 方法的地址。 实际上，调用者为我们提供了一个指向称为虚拟方法表或 vtable 的内存块的指针，该内存块包含所讨论类型的所有特征方法的实现地址，其中一个是 is_contained_in。 当方法中的代码想要在提供的模式上调用特征方法时，它会查找
该模式在 vtable 中实现 is_contained_in 的地址，然后调用该地址处的函数。 这允许我们使用相同的函数体，而不管调用者想要使用什么类型。

> 每个 vtable 还包含有关具体类型的布局和对齐的信息，因为始终需要该信息来处理类型。 如果您想了解显式 vtable 的示例，请查看 std::task::RawWakerVTable 类型。

您会注意到，当我们选择使用 dyn 关键字进行动态分派时，我们必须在其前面放置一个 &。 原因是我们在编译时不再知道调用者传入的模式类型的大小，所以我们不知道要为它留出多少空间。 换句话说，dyn Trait
是 !Sized，其中 ! 意思不是。 为了使其 Sized 以便我们可以将其作为参数，我们将其放在一个指针（我们知道其大小）后面。 因为我们还需要传递方法地址表，所以这个指针变成了一个宽指针，其中额外的字保存了指向 vtable 的指针。 您可以使用任何能够容纳动态分派的宽指针的类型，例如
作为 &mut、Box 和 Arc。 清单 2-3 显示了与清单 2-2 等效的动态调度。

```
impl String {
  pub fn contains(&self, p: &dyn Pattern) -> bool {
    p.is_contained_in(&*self)
  }
}
```
实现特征的类型及其 vtable 的组合称为特征对象。 大多数特征都可以变成特征对象，但不是全部。 例如，Clone trait，它的 clone 方法返回 Self，不能变成一个 trait 对象。 如果我们接受一个 dyn Clone trait 对象，然后对其调用 clone，编译器将不知道返回什么类型。 或者，考虑标准库中的 Extend 特征，它有一个方法 extend that
在提供的迭代器的类型上是通用的（因此可能有很多它的实例）。 如果你要调用一个采用 dyn Extend 的方法，将不会有单独的地址用于 extend 放置在 trait 对象的 vtable 中； 对于每一种可能被调用的扩展类型，都必须有一个条目。 这些是非对象安全特征的示例，因此可能不会变成特征对象。 为了对象安全，特征的方法都不能是通用的或使用 Self 类型。 此外，特征不能有任何静态方法（即第一个参数不解除对 Self 的引用的方法），因为不可能知道调用方法的哪个实例。 例如，不清楚 FromIterator::from_iter(&[0]) 应该执行什么代码。

在阅读 trait 对象时，您可能会看到 trait bound Self: Sized 的提及。 这样的界限意味着 Self 没有通过特征对象使用（因为它会被 !Sized）。 您可以将其绑定到特征上以要求该特征从不使用动态调度，或者您可以将 它在一个特定的方法上，当通过特征对象访问特征时使该方法不可用。 带有 where Self: Sized 边界的方法在检查特征是否是对象安全时被免除。 

动态调度缩短了编译时间，因为它不再是必需的。编译类型和方法的多个副本，它可以提高你的 CPU 指令缓存的效率。 但是，它也会阻止编译器针对所使用的特定类型进行优化。 使用动态分派，编译器可以为清单 2-2 中的 find 执行的所有操作是插入对 通过 vtable 的函数——它不能再执行任何额外的优化，因为它不知道什么代码将位于该函数调用的另一端。 此外，对 trait 对象的每个方法调用都需要在 vtable 中进行查找，这比直接调用该方法增加了少量开销。

当您在静态和动态调度之间做出选择时，很少有明确的正确答案。 不过，从广义上讲，您会希望在库中使用静态分派，在二进制文件中使用动态分派。 在图书馆中，您希望让您的用户决定哪种调度最适合他们，因为您不知道他们的需求是什么。 如果你使用动态调度，他们被迫做同样的事情，而如果你使用静态调度，他们可以选择是否使用动态调度。 另一方面，在二进制文件中，您正在编写最终代码，因此除了您正在编写的代码之外无需考虑。 动态调度通常允许您编写更简洁的代码，省去通用参数，编译速度更快，所有这些都以（通常）边际性能成本为代价，因此它通常是二进制文件的更好选择。

### 通用Trait

Rust traits 可以通过以下两种方式之一实现通用：使用通用类型参数，如 trait Foo<T> 或使用关联类型，如 trait Foo { type Bar; }. 它们之间的区别不是很明显，但幸运的是，经验法则非常简单：如果您希望给定类型的特性只有一个实现，则使用关联类型，否则使用泛型类型参数。

这样做的理由是关联类型通常更容易使用，但不允许多个实现。 因此，更简单地说，建议实际上只是尽可能使用关联类型。

对于通用特征，用户必须始终指定所有通用参数并重复这些参数的任何界限。 这很快就会变得混乱并且难以维护。 如果将通用参数添加到特征，则还必须更新该特征的所有用户以反映更改。 由于给定类型可能存在多个特征的实现，编译器可能很难决定您打算使用哪个特征实例，从而导致可怕的消除歧义的函数调用，如 FromIterator::<u32>::from_iter。 但好处是您可以多次实现该特征
相同的类型——例如，您可以针对您的类型的多个右侧类型实现 PartialEq，或者您可以同时实现 FromIterator<T> 和 FromIterator<&T>，其中 T：克隆，正是因为
通用特征提供的灵活性。

另一方面，对于关联类型，编译器只需要知道实现特征的类型，然后是所有关联类型（因为只有一个实现）。 这意味着边界可以全部存在于特征本身中，不需要在使用时重复。 反过来，这允许特征添加更多关联类型而不影响其用户。 而且因为类型决定了特征的所有关联类型，你永远不必用上一段中显示的统一函数调用语法来消除歧义。 但是，您不能对多个 Target 类型实现 Deref，也不能对多个不同的 Item 类型实现 Iterator。

### 一致性和孤儿规则

Rust 有一些相当严格的规则，关于你可以在哪里实现特征以及你可以在什么类型上实现它们。 这些规则的存在是为了保持一致性属性：对于任何给定的类型和方法，只有一个正确的选择用于该类型的方法实现。 要了解为什么这很重要，请考虑如果我可以为标准库中的 bool 类型编写自己的 Display 特性实现，会发生什么情况。 现在，对于任何试图打印 bool 值并包含我的 crate 的代码，编译器将不知道是选择我编写的实现还是标准库中的实现。 两种选择都不正确或优于另一种，编译器显然不能随机选择。 如果根本不涉及标准库，则会出现同样的问题，但我们有两个相互依赖的板条箱，它们都实现了某个共享类型的特征。 一致性属性确保编译器永远不会在这些情况下结束，也永远不必做出这些选择：总会有一个明显的选择。

维护一致性的一种简便方法是确保只有定义特征的板条箱才能为该特征编写实现； 如果没有其他人可以实现该特征，那么别处就不会有冲突的实现。 然而，这在实践中限制太多，并且基本上会使特征变得无用，因为没有办法为你自己的类型实现像 std::fmt::Debug 和 serde::Serialize 这样的特征，除非你将你自己的类型包含到 定义板条箱。 相反的极端，说你只能为你自己的类型实现特征，解决了这个问题但引入了另一个：定义特征的板条箱现在不能为标准库或其他流行的板条箱中的类型提供该特征的实现！ 理想情况下，我们希望找到一组规则来平衡下游 crate 为它们自己的类型实现上游特征的愿望与上游 crate 能够在不破坏下游代码的情况下添加它们自己的特征的实现的愿望。

> 上游指的是你的代码依赖的东西，下游指的是依赖你的代码的东西。 通常，这些术语在直接意义上使用
的板条箱依赖项，但它们也可以用来指代码库的权威分支——如果你做一个 Rust 编译器的分支，官方 Rust 编译器就是你的“上游”。

在 Rust 中，建立这种平衡的规则是孤儿规则。 简而言之，孤儿规则表示只有当特征或类型在您的板条箱本地时，您才能为类型实现特征。 所以，你可以为你自己的类型实现Debug，你可以为bool实现MyNeatTrait，但是你不能为bool实现Debug。 如果你尝试，你的代码将不会编译，编译器会告诉你存在冲突的实现。

这让你走得很远； 它允许您为第三方类型实现您自己的特征，并为您自己的类型实现第三方特征。 然而，孤儿规则并不是故事的结局。 您应该了解一些额外的含义、注意事项和例外情况。

#### Blanket Implementations

孤儿规则允许您使用 impl<T> MyTrait for T where T: 等代码在一系列类型上实现特征。 这是一个全面的实施——它不仅限于一种特定类型，而是适用于广泛的范围 的类型。 只有定义特征的包才被允许编写一揽子实现，并且将一揽子实现添加到现有特征被视为重大更改。 否则，包含 impl MyTrait for Foo 的下游 crate 可能会突然停止编译，因为您更新定义 MyTrait 的 crate 时出现有关实现冲突的错误。

#### 基本类型

有些类型非常重要，以至于有必要允许任何人在它们身上实现特征，即使这看起来违反了孤儿规则。 这些类型标有#[fundamental] 属性，目前包括 &、&mut 和 Box。 出于孤立规则的目的，基本类型也可能不存在——它们在检查孤立规则之前被有效地擦除，以便允许您，例如，为 &MyType 实现 IntoIterator。 仅使用孤立规则，此实现将不被允许，因为它为外部类型实现了外部特征——IntoIterator 和 & 都来自标准库。 在基本类型上添加一揽子实现也被视为重大更改。

#### 涵盖的实现

在某些有限的情况下，我们希望允许为外部类型实现外部特征，而孤儿规则通常不允许这样做。 最简单的例子是当你想为 Vec<i32> 编写类似 impl From<MyType> 的东西时。 在这里，From 特征是外来的，Vec 类型也是，
然而，不存在违反一致性的危险。 这是因为只能通过标准库中的一揽子实现来添加冲突的实现（标准库不能以其他方式命名 MyType），这无论如何都是一个重大变化。

为了允许这些类型的实现，孤儿规则包括：允许实施外国特征的狭义豁免 - eign 类型在一组非常特定的情况下。 具体来说，仅当至少一个 Ti 是局部类型，在第一个这样的 Ti 之前没有 T 是泛型类型 P1..=Pn 之一。 通用类型参数 (Ps) 允许出现在 T0..Ti 中，只要它们被某种中间类型覆盖即可。 如果 T 作为某个其他类型（如 Vec<T>）的类型参数出现，则它被覆盖，但如果它独立存在（只是 T）或仅出现在像 &T 这样的基本类型后面，则不被覆盖。 因此，清单 2-4 中的所有实现都是有效的。
```
impl<T> From<T> for MyType
impl<T> From<T> for MyType<T>
impl<T> From<MyType> for Vec<T>
impl<T> ForeignTrait<MyType, T> for Vec<T>
impl<T> ForeignTrait for T
impl<T> From<T> for T
impl<T> From<Vec<T>> for T
impl<T> From<MyType<T>> for T
impl<T> From<T> for Vec<T>
impl<T> ForeignTrait<T, MyType> for Vec<T>

```
当您为现有特征添加新实现时，孤立规则的放宽使构成重大更改的规则变得复杂。 特别是，向现有特征添加新的实现
仅当它包含至少一个新的本地类型并且该新的本地类型满足前面描述的豁免规则时才是不间断的。 添加任何其他新实现都是一项重大更改。

> 请注意 ForeignType 的 impl<T> ForeignTrait<LocalType, T> 是有效的，但 ForeignType 的 impl<T> ForeignTrait<T, LocalType> 无效！ 这可能看起来很武断，但如果没有这条规则，您可以编写 impl<T> ForeignTrait<T, LocalType>
对于 ForeignType，另一个 crate 可以为 ForeignType 写 impl<T> ForeignTrait<TheirType, T>，只有当两个 crate 放在一起时才会出现冲突。 孤立规则要求您的本地类型出现在类型参数之前，而不是完全禁止这种模式，这打破了平局并确保
如果两个板条箱在孤立的情况下都保持连贯性，那么它们在组合时也会保持一致。

### Trait Bounds

标准库与特征边界齐平，无论是 HashMap 中的键必须实现 Hash + Eq 还是赋予 thread::spawn 的函数必须是 FnOnce + Send + 'static。 当您自己编写泛型代码时，它几乎肯定会包含特征边界，否则您的代码无法对其泛型类型做太多事情。 当您编写更精细的通用实现时，您会发现您还需要更多的特征边界保真度，所以让我们看看实现这一目标的一些方法。

首先，特征边界不必是 T: Trait 的形式，其中 T 是某种类型，您的实现或类型是通用的。 边界可以是任意类型限制，甚至不需要包括泛型参数、参数类型或局部类型。 你可以像 where String: Clone 这样写一个 trait bound，即使 String: Clone 总是 true 并且不包含本地类型。 你也可以写 where io::Error: From<MyError<T>>; 您的泛型类型参数不需要只出现在左侧。 这不仅可以让您表达更复杂的边界，还可以避免不必要的重复边界。 例如，如果您的方法想要构造一个 HashMap<K, V, S> ，其键是一些泛型类型 T，其值是一个 usize，而不是像 where T: Hash+ Eq, S: BuildHasher + Default 那样写出边界 ，你可以写 where HashMap<T, usize, S>: FromIterator. 这使您无需查找最终使用的方法的确切边界要求，并且可以更清楚地传达代码的“真实”要求。 如您所见，如果您要调用的底层特征方法的边界很复杂，它还可以显着降低边界的复杂性。

> 虽然 #[derive(Trait)] 非常方便，但在特征边界的上下文中，您应该了解它通常如何实现的一个微妙之处。 许多 #[derive(Trait)] 将 desugar 扩展为 impl Trait for Foo<T> 其中
T：特质。 这通常是您想要的，但并非总是如此。 例如，考虑一下如果我们尝试以这种方式为 Foo<T> 派生 Clone 并且 Foo 包含一个 Arc<T> 会发生什么。 Arc 实现 Clone 而不管 T 是否实现 Clone，但是由于派生边界，Foo 仅当 T 实现时才实现 Clone！ 这通常不是什么大问题，但它确实在不需要的地方增加了一个界限。
如果我们将类型重命名为 Shared，问题可能会变得更清楚一些。 想象一下，当编译器告诉他们不能克隆它时，拥有 Shared<NotClone> 的用户会有多困惑！ 在撰写本文时，这就是标准库提供的#[derive(Clone)] 的工作方式，尽管这可能会在未来发生变化。

有时，您希望对泛型类型的关联类型进行限制。 例如，考虑迭代器方法 flatten，它采用生成项目的迭代器，该项目又实现 Iterator 并生成那些内部迭代器的项目的迭代器。 它产生的类型 Flatten 是 I 的泛型，它是外部迭代器的类型。 如果我实现 Iterator 并且我自己生成的项目实现 IntoIterator，则 Flatten 实现 Iterator。 为了使您能够像这样编写边界，Rust 允许您使用语法 Type::AssocType 来引用类型的关联类型。 例如，我们可以使用 I::Item 来引用 I 的 Item 类型。 如果一个类型有多个同名的关联类型，例如如果提供关联类型的特征本身是通用的（因此有很多实现），您可以使用语法 <Type as Trait>::AssocType 来消除歧义。 使用它，您不仅可以为外部迭代器类型编写边界，还可以为该外部迭代器的项类型编写边界。

在广泛使用泛型的代码中，您可能会发现需要编写一个绑定来讨论对类型的引用。 这通常很好，因为您往往还有一个通用的生命周期参数，您可以将其用作这些引用的生命周期。 然而，在某些情况下，您希望绑定说“此引用在任何生命周期内实现此特性”。 这种类型的边界被称为更高等级的特征边界，它在与 Fn 特征相关联时特别有用。 例如，假设您想对一个函数进行泛型化，该函数接受对 T 的引用并返回对该 T 内部的引用。如果您编写 F: Fn(&T) -> &U，则需要为那些引用提供生命周期 - ences，但你真的想说“只要输出与输入相同，任何生命周期”。 使用更高级别的生命周期，您可以编写 F: for<'a> Fn(&'a T) -> &'a U 表示对于任何生命周期 'a，边界必须成立。 Rust 编译器足够聪明，当您使用这样的引用编写 Fn 边界时，它会自动添加 for，这涵盖了此功能的大多数用例。 极少需要显式形式，在撰写本文时，标准库仅在三个地方使用它——但它确实发生了，因此值得了解。

为了将所有这些结合在一起，请考虑清单 2-6 中的代码，它可用于为任何可以迭代且其元素为 Debug 的类型实现 Debug。

```
impl Debug for AnyIterable
  where for<'a> &'a Self: IntoIterator,
        for<'a> <&'a Self as IntoIterator>::Item: Debug {
    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {
        f.debug_list().entries(self).finish()
}}
```

你可以为几乎任何集合类型复制粘贴这个实现，它会“正常工作”。 当然，您可能想要更智能的调试实现，但这很好地说明了特征边界的力量。

### Marker Traits

通常，我们使用特征来表示多种类型可以支持的功能； Hash类型可以调用hash进行哈希处理，Clone类型可以调用clone进行克隆，Debug类型可以调用fmt格式化调试。 但并非所有特征都以这种方式发挥作用。 一些特征称为标记特征，而是指示实现类型的属性。 标记特征没有方法或关联类型，仅用于告诉您可以或不能以某种方式使用特定类型。 例如，如果一个类型实现了 Send 标记特征，则跨线程边界发送是安全的。 如果它不实现此标记特征，则发送是不安全的。 没有与此行为关联的方法； 这只是关于类型的事实。 标准库在 std::marker 模块中有许多这些，包括 Send、Sync、Copy、Sized 和 Unpin。 其中大部分（除 Copy 外）也是自动特征； 编译器会自动为类型实现它们，除非该类型包含未实现标记特征的内容。

标记特征在 Rust 中有一个重要的用途：它们允许您编写边界来捕获未直接表达的语义要求
在代码中。 在要求类型为 Send 的代码中没有发送调用。 相反，代码假设给定的类型可以在单独的线程中使用，如果没有标记特征，编译器将无法检查该假设。 这将取决于程序员记住假设并非常仔细地阅读代码，我们都知道这不是我们想要依赖的东西。 该路径充满了数据竞争、段错误和其他运行时问题。

与标记特征相似的是标记类型。 这些是单元类型（如 struct MyMarker;），不包含任何数据，也没有任何方法。 标记类型对于将类型标记为处于特定状态非常有用。 当您想让用户无法滥用 API 时，它们会派上用场。 例如，考虑像 SshConnection 这样的类型，它可能已经过身份验证，也可能还没有。 您可以向 SshConnection 添加一个通用类型参数，然后创建两个标记类型：未验证和已验证。 当用户第一次连接时，他们会得到 SshConnection<Unauthenticated>。 在它的 impl 块中，您只提供一个方法：connect。 connect 方法返回一个 SshConnection<Authenticated>，并且只有在该 impl 块中，您才提供用于运行命令等的其余方法。 我们将在第 3 章进一步研究这种模式。

## Existential Types

在 Rust 中，你很少需要指定你在函数体中声明的变量类型或你调用的方法的泛型参数类型。 这是因为类型推断，编译器根据类型出现的代码的计算结果来决定使用什么类型。 编译器通常只会为变量和闭包的参数（和返回类型）推断类型； 函数、类型、特征和特征实现块等顶级定义都要求您显式命名所有类型。 这有几个原因，但主要原因是当您至少有一些已知点可以从中开始推断时，类型推断会容易得多。 然而，完全命名一个类型并不总是那么容易，甚至不可能！ 例如，如果你从一个函数返回一个闭包，或者从一个 trait 方法返回一个异步块，它的类型没有你可以输入到你的代码中的名称。

为了处理这种情况，Rust 支持存在类型。 很有可能，您已经看到实际存在类型。 所有标记为 async fn 或返回类型为 impl Trait 的函数都有一个存在的返回类型：签名不给出返回值的真实类型，只是暗示函数返回某种实现某些特征集的类型 来电者可以依靠。 至关重要的是，调用者只能依赖于实现这些特征的返回类型，而不是其他任何东西。

>从技术上讲，调用者依赖于返回类型而不依赖于其他任何东西是不严格的。 编译器还将通过返回位置的 impl Trait 传播发送和同步等自动特征。 我们将在下一章中对此进行更多讨论。

这种行为为存在类型赋予了名称：我们断言存在一些与签名匹配的具体类型，我们将其留给编译器来查找该类型是什么。 然后，编译器通常会通过对函数体应用类型推断来解决这个问题。

并非所有 impl Trait 实例都使用存在类型。 如果你在函数的参数位置使用 impl Trait，它实际上只是该函数的未命名通用参数的简写。 例如，fn foo(s: impl ToString) 主要只是 fn foo<S: ToString>(s: S) 的语法糖。

存在类型会派上用场，特别是当您实现具有关联类型的特征时。 例如，假设您正在实现 IntoIterator 特性。 它有一个相关联的类型 IntoIter 保存类型
可以将所讨论的类型转换成的迭代器。 使用存在类型，您不需要定义单独的迭代器类型来用于 IntoIter。 相反，您可以将关联类型指定为 impl Iterator<Item = Self::Item> 并仅在 fn into_iter(self) 中编写一个表达式，该表达式的计算结果为迭代器，例如通过对某些现有迭代器类型使用映射和过滤器。

存在类型还提供了一个不仅仅是方便的特性：它们允许您执行零成本类型擦除。 与其导出辅助类型只是因为它们出现在某个地方的公共签名中——迭代器和未来是这方面的常见例子——你可以使用存在类型来隐藏底层的具体类型。 您的接口的用户仅显示相关类型实现的特征，而具体类型作为实现细节保留。 这不仅简化了接口，而且还使您能够根据需要更改该实现，而无需在将来破坏下游代码。

## 总结

本章全面回顾了 Rust 类型系统。 我们已经了解了编译器如何在内存中显示类型以及它如何推理类型本身。 这是后面章节中编写不安全代码、复杂应用程序接口和异步代码的重要背景材料。 你还会发现，本章中的大部分类型推理都会影响你如何设计 Rust 代码接口，我们将在下一章中介绍。