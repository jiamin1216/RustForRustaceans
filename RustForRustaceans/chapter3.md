# 接口设计

每个项目，无论大小，都有一个 API；事实上，它通常有几个。 其中一些是面向用户的，例如 HTTP 端点或命令行界面，以及有些是面向开发人员的，比如图书馆的公共接口。除此之外，Rust crates 还有一定数量的内部接口：每个类型、特征和模块边界都有自己的微型 API，其余代码与之交互。 随着您的代码库的规模和复杂性的增加，您会发现值得投入一些思考和关注如何设计内部API，以使随着时间的推移使用和维护代码的体验尽可能愉快。

在本章中，我们将探讨在 Rust 中编写惯用接口的一些最重要的考虑因素，无论这些接口的用户是您自己的代码还是使用您的库的其他开发人员。 这些基本上可以归结为四个原则：您的接口设计应该是容易理解的、灵活的、定义清晰的和受约束的。 我将依次讨论这些原则中的每一个，为编写可靠且可用的接口提供一些指导。

我强烈建议您在阅读本章后查看 Rust API 指南 (https://rust-lang.github.io/api-guidelines/)。 您可以遵循一份出色的清单，其中包含每项建议的详细说明。 本章中的许多建议也通过 cargo clippy 工具进行检查，如果您还没有开始在您的代码上运行，您应该开始运行它。 我还鼓励您通读 Rust RFC 1105 (https://rust-lang.github.io/rfcs/1105-api-evolution.html) 和 The Cargo Book 中关于 SemVer 兼容性的章节 (https://doc. rust-lang.org/cargo/reference/semver.html），其中涵盖了 Rust 中什么是和不是什么重大变化。

## 最小惊喜原则（一致性原则）

[least-surprise定义](https://www.centercode.com/glossary/principle-of-least-surpris)

最小惊奇原则，也称为最小惊奇法则，在软件工程中经常出现，它也适用于 Rust 接口设计。 在可能的情况下，您的接口应该足够直观，如果用户必须猜测，他们通常会猜对。 当然，并不是关于您的应用程序的所有内容都会以这种方式立即变得直观，但任何可能不足为奇的东西都应该是。 这里的核心思想是紧贴用户可能已经知道的事物，这样他们就不必以不同于他们习惯的方式重新学习概念。 这样你就可以节省他们的脑力来弄清楚你的界面实际上特定的东西。
有多种方法可以使您的界面可预测。 在这里，我们将看看如何使用命名、共同特征和人体工程学特征技巧来帮助用户。

### 命名惯例

接口的用户首先会通过它的名字遇到它； 他们会立即开始根据他们遇到的类型、方法、变量、字段和库的名称来推断事物。 如果您的接口重用其他（可能是通用的）接口中的事物名称（例如，方法和类型），用户就会知道他们可以对您的方法和类型做出某些假设。 一个名为 iter 的方法可能接受 &self，并可能给你一个迭代器。 称为 into_inner 的方法可能采用 self 并可能返回某种包装类型。 称为 SomethingError 的类型可能实现了 std::error::Error 并出现在各种结果中。 通过为相同的目的重复使用通用名称，您可以让用户更容易猜出事物的作用，并让他们更容易理解您的接口的不同之处。

一个推论是，同名的事物实际上应该以相同的方式工作。 否则——例如，如果你的 iter 方法采用 self，或者如果你的 SomethingError 类型没有实现 Error——用户可能会根据他们期望接口的工作方式编写不正确的代码。 他们会感到惊讶和沮丧，并且不得不花时间深入研究您的接口与他们的期望有何不同。 当我们可以为用户避免这种摩擦时，我们应该这样做。

### 类型的通用Traits

Rust 的用户还会做出主要假设，即接口中的所有内容都“正常工作”。 他们希望能够使用 {:?} 打印任何类型并将所有内容发送到另一个线程，并且他们希望每种类型都是克隆。 在可能的情况下，我们应该再次避免让用户感到惊讶，并热切地实现大多数标准特性，即使我们并不立即需要它们。

由于第 2 章中讨论的一致性规则，编译器将不允许用户在需要时实现这些特征。 不允许用户为您的接口中的外部类型实现外部特征（例如克隆）。 相反，他们需要将您的接口类型包装在他们自己的类型中，即使这样，如果不访问类型的内部结构，也可能很难编写合理的实现。

这些标准特性中的第一个是调试特性。 几乎每个类型都可以而且应该实现 Debug，即使它只打印类型的名称。 使用#[derive(Debug)] 通常是在接口中实现 Debug 特性的最佳方式，但请记住，所有派生特性都会自动为任何通用参数添加相同的绑定。 您也可以通过利用 fmt::Formatter 上的各种 debug_ 助手来简单地编写自己的实现。

紧随其后的是 Rust 自动特性 Send 和 Sync（以及，在较小程度上，Unpin）。 如果一个类型没有实现这些特征之一，那应该是有充分理由的。 不是 Send 的类型不能放在 Mutex 中，甚至不能在包含线程池的应用程序中传递使用。 非 Sync 的类型不能通过 Arc 共享或放置在静态变量中。 用户已经开始期望类型只在这些上下文中工作，尤其是在几乎所有内容都在线程池上运行的异步世界中，如果您不确保您的类型实现这些特征，他们会感到沮丧。 如果您的类型无法实现它们，请确保将这一事实及其原因记录在案！

您应该实现的下一组几乎通用的特征是克隆和默认。 这些特征可以很容易地派生或实现，并且对大多数类型都有意义。 如果您的类型无法实现这些特征，请确保在您的文档中将其调出，因为用户通常希望能够轻松地创建更多（和新的）他们认为合适的类型实例。 如果他们做不到，他们会感到惊讶。

在预期特征的层次结构中再往下一层是比较特征：PartialEq、PartialOrd、Hash、Eq 和 Ord。 PartialEq 特性是特别可取的，因为用户在某些时候不可避免地会有两个你的类型的实例，他们希望将它们与 == 或 assert_eq! 进行比较。 即使您的类型仅针对该类型的相同实例比较相等，也值得实现 PartialEq 以使您的用户能够使用 assert_eq!。

PartialOrd 和 Hash 更专业，可能应用不那么广泛，但如果可能，您也希望实现它们。 对于用户可能用作映射中的键的类型，或者他们可能使用任何 std::collection 集类型进行重复数据删除的类型，尤其如此，因为它们往往需要这些边界。 除了 PartialEq 和 PartialOrd 之外，Eq 和 Ord 对实现类型的比较操作有额外的语义要求。 这些在这些特性的文档中有详细的记录，只有当您确定这些语义确实适用于您的类型时，您才应该实现它们。

最后，对于大多数类型，实现 serde crate 的序列化和反序列化特征是有意义的。 这些可以很容易地派生，并且 serde _derive crate 甚至带有仅覆盖一个字段或枚举变体的序列化的机制。 由于 serde 是第三方 crate，您可能不希望在其上添加必需的依赖项。 因此，大多数库选择提供 serde 功能，仅当用户选择加入时才添加对 serde 的支持。

您可能想知道为什么我没有在本节中包含可派生特征 Copy。 有两点使 Copy 与提到的其他特征区分开来。 首先是用户通常不希望类型是 Copy； 恰恰相反，他们倾向于期望如果他们想要某些东西的两个副本，他们必须调用克隆。 Copy 改变了移动给定类型的值的语义，这可能会让用户感到惊讶。 这与第二个观察结果相关：一个类型很容易不再是 Copy，因为 Copy 类型受到高度限制。 一个开始时很简单的类型很容易最终不得不持有一个 String 或其他一些非 Copy 类型。 如果发生这种情况，您必须删除 Copy 实现，这是一个向后不兼容的更改。 相比之下，您很少需要删除克隆实现，因此这是一个不那么繁重的承诺。

### 人体工程学特征实现

Rust 不会自动为对实现特征的类型的引用实现特征。 换句话说，您通常不能用 &Bar 调用 fn foo<T: Trait>(t: T)，即使 Bar: Trait. 这是因为 Trait 可能包含采用 &mut self 或 self 的方法，这些方法显然不能在 &Bar 上调用。 尽管如此，对于看到 Trait 只有 &self 方法的用户来说，这种行为可能会非常令人惊讶！

出于这个原因，当您定义一个新特征时，您通常需要为该特征提供合适的一揽子实现，例如 &T where T: Trait、&mut T where T: Trait 和 Box<T> where T: Trait . 您可能只能实现其中的一些，具体取决于 Trait 方法的接收者。 标准库中的许多特性都有类似的实现，正是因为这会减少用户的意外。

迭代器是另一种情况，在这种情况下，您经常希望在对类型的引用上专门添加特征实现。 对于任何可以迭代的类型，请考虑在适用的情况下为 &MyType 和 &mut MyType 实现 IntoIterator。 这使得 for 循环可以开箱即用地使用你的类型的借用实例，就像用户所期望的那样。

### 类型封装

Rust 没有经典意义上的对象继承。 然而，Deref trait 和它的表亲 AsRef 都提供了一些类似于继承的东西。 如果 T: Deref<Target = U>，这些特征允许您拥有类型 T 的值并通过直接在 T 类型的值上调用它们来调用某些类型 U 上的方法。 这对用户来说就像魔法一样，而且通常很棒。

如果你提供了一个相对透明的包装器类型（比如 Arc），你很有可能想要实现 Deref，这样用户就可以通过使用 . 操作员。 如果访问内部类型不需要任何复杂或可能很慢的逻辑，您还应该考虑实现 AsRef，它允许用户轻松地将 &WrapperType 用作 &InnerType。 对于大多数包装类型，您还需要尽可能实现 From<InnerType> 和 Into<InnerType> ，以便您的用户可以轻松添加或删除您的包装。

您可能还遇到过 Borrow 特性，它感觉与 Deref 和 AsRef 非常相似，但实际上又有点不同。 具体来说，Borrow 是为更窄的用例量身定制的：允许调用者提供同一类型的多个基本相同变体中的任何一个。 或许，它可以被称为等效的。 例如，对于 HashSet<String>，Borrow 允许调用者提供 &str 或 &String。 虽然使用 AsRef 也可以达到同样的效果，但如果没有 Borrow 的附加要求，即目标类型实现与实现类型完全相同的 Hash、Eq 和 Ord，那将是不安全的。 Borrow 还为 T、&T 和 &mut T 全面实现了 Borrow<T>，这使得在 trait bounds 中使用它来接受给定类型的拥有值或引用值变得很方便。 通常，Borrow 仅适用于当您的类型本质上等同于另一种类型时，而 Deref 和 AsRef 旨在更广泛地实现您的类型可以“充当”的任何事物。

>当 T 上有采用 self 的方法时，围绕点运算符和 Deref 的魔法可能会让人感到困惑和惊讶。 例如，给定一个值 t: T，不清楚 t.frobnicate() 是冻结 T 还是底层的 U！
出于这个原因，允许您透明地调用一些事先不知道的内部类型的方法的类型应该避免使用固有方法。 Vec 有 push 方法很好，即使它取消对切片的引用，因为你知道切片不会很快获得 push 方法。 但是，如果您的类型取消对用户控制类型的引用，则您添加的任何固有方法也可能存在于该用户控制类型上，从而导致问题。 在这些情况下，支持 fn frobnicate(t: T) 形式的静态方法。 这样，t.frobnicate() 总是调用 U::frobnicate，而 T::frobnicate(t) 可用于对 T 本身进行 frobnicate。

## 灵活原则

您编写的每段代码都隐含或明确地包含一个合同。 合同（合约）由一组要求和一组承诺组成，需求是对代码如何使用的限制，而承诺是对代码如何使用的保证。 在设计一个新的接口时，你要仔细考虑这个契约。 一个好的经验法则是避免强加不必要的限制，只做出你可以信守的承诺。 添加限制或删除承诺通常需要主要的语义版本更改，并且可能会破坏其他地方的代码。 另一方面，放宽限制或给予额外承诺通常是向后兼容的。

在 Rust 中，限制通常以特征边界和参数类型的形式出现，而承诺以特征实现和返回类型的形式出现。 例如，比较清单 3-1 中的三个函数签名。

```
fn frobnicate1(s: String) -> String
fn frobnicate2(s: &str) -> Cow<'_, str>
fn frobnicate3(s: impl AsRef<str>) -> impl AsRef<str>
```
这三个函数签名都接受一个字符串并返回一个字符串，但它们在非常不同的合同下这样做。

第一个函数要求调用者拥有 String 类型形式的字符串，并承诺将返回一个拥有的 String。 由于合约要求调用者分配并要求我们返回一个拥有的字符串，我们以后不能以向后兼容的方式使该函数免分配。  

第二个函数放宽了契约：调用者可以提供对字符串的任何引用，因此用户不再需要分配或放弃对字符串的所有权。 它还承诺返回一个 std::borrow::Cow，这意味着它可以返回一个字符串引用或一个拥有的字符串，具体取决于它是否需要拥有该字符串。 这里的承诺是该函数将始终返回一个 Cow，这意味着我们以后不能更改它以使用其他一些优化的字符串表示形式。 调用者还必须特别提供一个 &str，所以如果他们有，比方说，他们自己的一个预先存在的字符串，他们必须将它取消引用到一个 &str 来调用我们的函数。

第三个功能解除了这些限制。 它只要求用户传入一个可以产生对字符串的引用的类型，并且只承诺返回值可以产生对字符串的引用。

这些函数签名都不比其他函数签名好。 如果您需要函数中字符串的所有权，您可以使用第一个参数类型来避免额外的字符串复制。 如果你想让调用者利用分配并返回一个拥有的字符串的情况，返回类型为 Cow 的第二个函数可能是一个不错的选择。 相反，我希望你从这里得到的是，你应该仔细考虑你的界面将你绑定到什么契约，因为事后改变它可能会造成破坏。

在本节的其余部分，我给出了经常出现的接口设计决策的示例，以及它们对您的接口契约的影响。

### 通用参数

您的接口必须对用户提出的一个明显要求是他们必须为您的代码提供哪些类型。 如果您的函数明确采用 Foo，则用户必须拥有并给您一个 Foo。 在大多数情况下，使用泛型而不是具体类型是值得的，它允许调用者传递符合您的函数实际需要的任何类型，而不仅仅是特定类型。 将清单 3-1 中的 &str 更改为 impl AsRef<str> 就是这种放松的一个例子。 以这种方式放宽要求的一种方法是从参数完全通用且无边界开始，然后只需按照编译器错误来发现需要添加的边界。

然而，如果走极端，这种方法会使每个函数的每个参数都有自己的泛型类型，这将既难以阅读又难以理解。 对于何时应该或不应该使给定参数通用化并没有硬性规定，因此请使用您的最佳判断。 如果您能想到用户可能合理且经常想要使用的其他类型而不是您开始时使用的具体类型，那么一个好的经验法则是使参数通用。

您可能还记得第 2 章中的内容，泛型代码对于通过单态化与泛型代码一起使用的每种类型组合都是重复的。 考虑到这一点，使大量参数通用的想法可能会让您担心过度扩大二进制文件。 在第 2 章中，我们还讨论了如何使用动态调度以（通常）可以忽略不计的性能成本来缓解这种情况，这也适用于此。 对于你通过引用获取的参数（回想一下 dyn Trait 没有大小，并且你需要一个宽指针来使用它们），你可以很容易地用使用动态调度的参数替换你的通用参数。 例如，您可以使用 &dyn AsRef<str> 而不是 impl AsRef<str>。

不过，在你开始跑步之前，你应该考虑一些事情。 首先，您是代表您的用户做出此选择，他们不能选择退出动态调度。 如果你知道你正在应用动态调度的代码永远不会对性能敏感，那可能没问题。 但是，如果一个用户想要在他们的高性能应用程序中使用您的库，那么在热循环中调用的函数中进行动态调度可能会破坏交易。 其次，在撰写本文时，仅当您具有像 T: AsRef<str> 或 impl AsRef<str> 这样的简单特征绑定时，使用动态调度才有效。 对于更复杂的边界，Rust 不知道如何构造一个动态调度 vtable，所以你不能采用，比如说，&dyn Hash + Eq。 最后，请记住，使用泛型时，调用者始终可以通过传入特征对象来自行选择动态调度。 反之则不然：如果你接受一个特征对象，那是调用者必须提供的。

从具体类型开始你的接口可能很诱人，然后随着时间的推移将它们变成通用的。 这可行，但请记住，此类更改不一定向后兼容。 要了解原因，假设您将函数从 fn foo(v: &Vec<usize>) 更改为 fn foo(v: impl AsRef<[usize]>)。 虽然每个 &Vec<usize> 都实现了 AsRef<[usize]>，但类型推断仍然会给用户带来问题。 考虑一下如果调用者用 foo(&iter.collect()) 调用 foo 会发生什么。 在原始版本中，编译器可以确定它应该收集到一个 Vec 中，但现在它只知道它需要收集到某种实现 AsRef<[usize]> 的类型中。 并且可能有多个这样的类型，所以随着这个变化，调用者的代码将不再编译！

### 对象安全

当你定义一个新的特征时，这个特征是否是对象安全的（见第 2 章“编译和调度”的结尾）是特征契约的未成文部分。 如果特征是对象安全的，用户可以使用 dyn Trait 将实现特征的不同类型视为单一的通用类型。 如果不是，编译器将不允许该特征使用 dyn Trait。 你应该更喜欢你的特征是对象安全的，即使这对使用它们的人机工程学有轻微的代价（例如使用 impl AsRef<str> 而不是 &str），因为对象安全允许以新的方式使用你的特征。 如果你的特征必须有一个泛型方法，考虑它的泛型参数是否可以在特征本身上，或者它的泛型参数是否也可以使用动态调度来保护特征的对象安全。 或者，您可以添加一个 where Self: Sized trait 绑定到该方法，这样就可以仅使用该 trait 的具体实例（而不是通过 dyn Trait）调用该方法。 您可以在 Iterator 和 Read 特征中看到此模式的示例，它们是对象安全的，但在具体实例上提供了一些额外的便利方法。

对于您应该愿意为保护对象安全做出多少牺牲的问题，没有单一的答案。 我的建议是您考虑如何使用您的特征，以及用户想要将其用作特征对象是否有意义。 如果您认为用户可能希望同时使用您的特征的许多不同实例，那么您应该更加努力地提供对象安全，而不是您认为该用例没有多大意义。 例如，动态分派对 FromIterator 特性没有用，因为它的一个方法不采用 self，所以 你一开始就无法构造一个特征对象。 类似地，std::io::Seek 本身作为一个特征对象是相当无用的，因为你唯一能用这样的特征对象做的就是寻找，而不能读或写。

> 您可能认为 Drop trait 作为 trait 对象也是无用的，因为将 Drop 作为 trait 对象，您所能做的就是将其丢弃。 但事实证明，有些库专门希望能够删除任意类型。 例如，一个提供延迟删除值的库，例如并发垃圾收集或延迟清理，只关心值是否可以删除，而不关心其他。 有趣的是，Drop 的故事并没有就此结束； 因为 Rust 也需要能够删除 trait 对象，所以每个 vtable 都包含 drop 方法。 实际上，每个 dyn Trait 也是一个 dyn Drop 。

请记住，对象安全是公共接口的一部分！ 如果您以其他向后兼容的方式修改特征，例如通过添加具有默认实现的方法，但这会使特征不是对象安全的，则您需要增加主要语义版本号。

### 借用 VS 拥有

对于您在 Rust 中定义的几乎每个函数、特征和类型，您必须决定它是否应该拥有，或者只是持有对其数据的引用。 无论您做出什么决定，都会对您的界面的人体工程学和性能产生深远的影响。 幸运的是，这些决定通常是自己做出的。

如果您编写的代码需要数据的所有权，例如调用采用 self 的方法或将数据移动到另一个线程，则它必须存储拥有的数据。 当您的代码必须拥有数据时，它通常还应该让调用者提供拥有的数据，而不是通过引用获取值并克隆它们。 这让调用者可以控制分配，并且预先了解使用相关接口的成本。

另一方面，如果您的代码不需要拥有数据，则它应该对引用进行操作。 此规则的一个常见例外是像 i32、bool 或 f64 这样的小类型，它们直接存储和复制与通过引用存储一样便宜。 但是，要小心假设这适用于所有 Copy 类型； [u8; 8192] 是 Copy，但是到处存储和复制它会很昂贵。

当然，在现实世界中，事情往往不那么明确。 有时，您事先不知道您的代码是否需要拥有数据。 例如，String::from_utf8_lossy 需要取得传递给它的字节序列的所有权，只有当它包含无效的 UTF-8 序列时。 在这种情况下，Cow 类型是您的朋友：如果数据允许，它可以让您对引用进行操作，并且如果需要，它可以让您生成拥有的值。

其他时候，引用生命周期使接口变得非常复杂，以至于使用起来很痛苦。 如果您的用户正在努力让代码在您的界面上进行编译，这表明您可能想要（甚至是不必要地）获得某些数据的所有权。 如果你这样做，在你决定堆分配可能是一个巨大的字节块之前，从克隆成本低或不属于任何性能敏感的数据开始。

### 容易出错和阻塞的析构函数

以 I/O 为中心的类型在被丢弃时通常需要执行清理。 这可能包括刷新磁盘写入、关闭文件或优雅地终止与远程主机的连接。 执行此清理的自然位置是在类型的 Drop 实现中。 不幸的是，一旦一个值被删除，我们就没有办法向用户传达错误信息，除非是恐慌。 类似的问题出现在异步代码中，我们希望在有待处理的工作时完成。 当 drop 被调用时，executor 可能正在关闭，我们没有办法做更多的工作。 我们可以尝试启动另一个执行器，但这会带来一系列问题，例如异步代码中的阻塞，我们将在第 8 章中看到。

这些问题没有完美的解决方案，无论我们做什么，一些应用程序都不可避免地会退回到我们的 Drop 实现。 出于这个原因，我们需要通过 Drop 提供尽力而为的清理。 如果清理错误，至少我们尝试过——我们吞下错误并继续前进。 如果执行器仍然可用，我们可能会产生一个 future 来进行清理，但如果它永远无法运行，我们会尽力而为。

但是，我们应该为希望不留下任何松散线程的用户提供更好的选择。 我们可以通过提供一个显式的析构函数来做到这一点。 这通常采用一种方法的形式，该方法取得 self 的所有权并公开销毁固有的任何错误（使用 -> Result<_, _>）或异步（使用 async fn）。 细心的用户然后可以使用该方法优雅地拆除任何关联的资源。

> 确保在文档中突出显示显式析构函数！

与往常一样，需要权衡取舍。 在添加显式析构函数的那一刻，您将遇到两个问题。 首先，由于您的类型实现了 Drop，您不能再在析构函数中移出该类型的任何字段。 这是因为 Drop::drop 在显式析构函数运行后仍会被调用，并且它需要 &mut self，这要求 self 的任何部分都没有被移动。 其次，drop 采用 &mut self，而不是 self，因此您的 Drop 实现不能简单地调用显式析构函数并忽略其结果（因为它不拥有 self）。 有几种方法可以解决这些问题，但没有一种是完美的。

第一个是让你的顶级类型成为一个新类型的包装器 一个选项，它又包含一些内部类型，该类型包含该类型的所有字段。 然后，您可以在两个析构函数中使用 Option::take，并且仅当内部类型尚未被采用时才调用内部类型的显式析构函数。 由于内部类型不实现 Drop，您可以取得那里所有字段的所有权。 这种方法的缺点是，您希望在顶级类型上提供的所有方法现在都必须包含代码以通过 Option（您知道它总是 Some，因为尚未调用 drop）到内部的字段 类型。

第二种解决方法是使您的每个字段都可用。 你可以通过用 None 替换它来“接受”一个 Option（这就是 Option::take 所做的），但你也可以用许多其他类型来做到这一点。 例如，您可以通过简单地将它们替换为构造成本低廉的默认值来获取 Vec 或 HashMap — std::mem::take 是您的朋友。 如果您的类型具有合理的“空”值，则此方法非常有效，但如果您必须将几乎每个字段都包装在一个选项中，然后使用匹配的解包修改对这些字段的每个访问，则会变得乏味。

第三个选项是将数据保存在 ManuallyDrop 类型中，它取消对内部类型的引用，因此不需要解包。 您还可以使用 ManuallyDrop::take in drop 在销毁时获取所有权。 这种方法的主要缺点是 ManuallyDrop::take 是不安全的。 没有适当的安全机制来确保您在调用 take 之后不会尝试使用 ManuallyDrop 中的值，或者您不会多次调用 take。 如果这样做，您的程序将悄无声息地表现出未定义的行为，并且会发生不好的事情。

最终，您应该选择最适合您的应用程序的方法。 我宁愿选择第二个选项，只有当你发现自己处于选项的海洋中时才切换到其他选项。 如果代码足够简单，您可以轻松检查代码的安全性，并且您对自己的能力有信心，则 ManuallyDrop 解决方案非常出色。

## 清晰原则

虽然一些用户可能熟悉支持您的接口的实现，但他们不太可能理解其所有规则和限制。 他们不会知道在调用 bar 之后再调用 foo 是不安全的，或者只有当月亮处于 47 度角并且在过去 18 秒内没有人打喷嚏时调用不安全的方法 baz 才是安全的。 只有当接口清楚地表明发生了一些奇怪的事情时，他们才会去查阅文档或仔细阅读类型签名。 因此，让用户尽可能容易地理解您的接口，并尽可能地防止他们错误地使用接口对您来说至关重要。 为此，您可以使用的两种主要技术是您的文档和类型系统，所以让我们依次看看它们中的每一种。

> 您还可以利用命名来向用户提供建议，当接口的内容比您看到的要多时。 如果用户看到一个名为 dangerous 的方法，他们很可能会阅读它的文档。

### 文档

使接口透明的第一步是编写好的文档。 我可以写一整本书专门介绍如何编写文档，但让我们在这里关注 Rust 特定的建议。

首先，清楚地记录任何你的代码可能会做一些意外的事情，或者它依赖于用户做一些超出类型签名规定的事情的情况。 恐慌是这两种情况的一个很好的例子：如果你的代码可能会恐慌，记录这个事实，以及它可能恐慌的情况。 同样，如果您的代码可能会返回错误，请记录它返回错误的情况。 对于不安全的函数，记录调用者必须保证的内容，以便调用是安全的。

其次，在板条箱和模块级别包含代码的端到端使用示例。 这些比特定类型或方法的示例更重要，因为它们让用户了解所有内容是如何组合在一起的。 通过对接口结构的高度理解，开发人员可能很快就会意识到特定方法和类型的作用以及应该在何处使用它们。 端到端示例还为用户提供了一个自定义其用法的起点，他们可以并且经常会复制粘贴示例，然后对其进行修改以满足他们的需要。 这种“边做边学”的方法往往比让他们尝试从组件中拼凑一些东西更有效。

> 非常特定于方法的示例表明，是的，len 方法确实返回了长度，不太可能告诉用户有关您的代码的任何新内容。

第三，组织你的文档。 将所有类型、特征和函数都放在一个顶级模块中会使用户很难了解从哪里开始。 利用模块将语义相关的项目组合在一起。 然后，使用文档内链接来链接项目。 如果关于类型 A 的文档谈到了特征 B，那么它应该链接到那个特征。 如果你让用户更容易浏览你的界面，他们就不太可能错过重要的联系或依赖。 还可以考虑使用 #[doc(hidden)] 标记界面中不打算公开但出于遗留原因需要的部分，这样它们就不会弄乱您的文档。

最后，尽可能丰富您的文档。 链接到解释概念、数据结构、算法或界面的其他方面的外部资源，这些资源可能在其他地方有很好的解释。 RFC、博客文章和白皮书对此非常有用（如果有的话）。 使用#[doc(cfg(..))] 突出显示仅在某些配置下可用的项目，以便用户快速意识到为什么文档中列出的某些方法不可用。 使用 #[doc(alias = "...")] 使类型和方法可以在用户可以搜索它们的其他名称下被发现。 在顶层文档中，将用户指向常用的模块、特性、类型、特征和方法。

### 类型系统指南

类型系统是一个极好的工具，可以确保你的接口是显而易见的、自我记录的和防误用的。 您可以使用多种技术来使您的接口很难被滥用，从而使它们更有可能被正确使用。

第一个是语义类型化，您可以在其中添加类型来表示值的含义，而不仅仅是其原始类型。 这里的经典示例是针对布尔值的：如果您的函数采用三个布尔参数，则很可能某些用户会弄乱值的顺序，并且只有在出现严重错误后才会意识到这一点。 另一方面，如果它采用不同的双变量枚举类型的三个参数，则用户不会在编译器对它们大喊大叫的情况下弄错顺序：如果它们试图将 DryRun::Yes 传递给覆盖参数，那只会 不起作用，也不会将 Overwrite::No 作为 dry_run 参数传递。 您也可以在布尔值之外应用语义类型。 例如，围绕数字类型的新类型可以为包含的值提供一个单位，或者它可以将原始指针参数限制为仅由另一个方法返回的参数。

一种密切相关的技术是使用零大小的类型来指示关于类型实例的特定事实为真。 例如，考虑一种称为 Rocket 的类型，它表示真实火箭的状态。 无论火箭处于什么状态，Rocket 上的某些操作（方法）都应该可用，但有些操作（方法）仅在特定情况下才有意义。 例如，如果火箭已经发射，就不可能再发射。 同样，如果火箭还没有发射，应该不可能分离燃料箱。 我们可以将它们建模为枚举变体，但是所有方法在每个阶段都可用，我们需要引入可能的恐慌。

相反，如清单 3-2 所示，我们可以在 Rocket Stage 上引入一个泛型参数，并用它来限制哪些方法在什么时候可用。
```
1struct Grounded;
struct Launched;
// and so on
struct Rocket<Stage = Grounded> {
2 stage: std::marker::PhantomData<Stage>, 
}
3 impl Default for Rocket<Grounded> {} impl Rocket<Grounded> {
    pub fn launch(self) -> Rocket<Launched> { }
  }
4 impl Rocket<Launched> {
pub fn accelerate(&mut self) { } pub fn decelerate(&mut self) { }
}
5 impl<Stage> Rocket<Stage> {
pub fn color(&self) -> Color { }
pub fn weight(&self) -> Kilograms { }
}
```

我们引入单位类型来表示Rocket 1 的每个级。我们实际上不需要存储级——只需要存储它提供的元信息——所以我们将它存储在 PhantomData 2 后面以保证它在编译时被消除。 然后，我们只在 Rocket 持有特定类型参数时为它编写实现块。 你只能在地面上建造火箭（目前），你只能从地面发射它 3.

只有当Rocket被发射后，你才能控制它的速度 4。有些事情你总是可以用火箭做，不管它处于什么状态，以及我们放在通用实现块 5 中的那些事情。你会注意到 以这种方式设计的接口，用户根本不可能在错误的时间调用方法——我们已经在类型本身中编码了使用规则，并使非法状态无法表示。

这个概念也延伸到许多其他领域； 如果您的函数忽略指针参数，除非给定的布尔参数为真，最好将这两个参数结合起来。 使用一种枚举类型，其中一种变体表示 false（没有指针），另一种表示 true 并包含指针，调用者和实现者都不会误解两者之间的关系。 这是一个强大的想法，我强烈建议您加以利用。

另一个使接口显而易见的小而有用的工具是#[must _use] 注释。 将它添加到任何类型、特征或函数，如果用户的代码接收到该类型或特征的元素，或调用该函数，但没有明确处理它，编译器将发出警告。 您可能已经在 Result 的上下文中看到了这一点：如果一个函数返回一个 Result 而您没有在某处分配它的返回值，您会收到编译器警告。 但是要注意不要过度使用这个注解——只有当用户不使用返回值而很可能会犯错误时才添加它。

## 约束原则

随着时间的推移，一些用户将依赖于您界面的每个属性，无论是错误还是功能。 对于您无法控制用户的公共可用图书馆尤其如此。 因此，在进行用户可见的更改之前，您应该仔细考虑。 无论您是添加新的类型、字段、方法或特征实现，还是更改现有的，您都希望确保更改不会破坏现有用户的代码，并且您计划将更改保留一段时间 尽管。 频繁的向后不兼容更改（语义版本控制中的主要版本增加）肯定会引起用户的愤怒。

许多向后不兼容的更改是显而易见的，例如重命名公共类型或删除公共方法，但有些更微妙并且与 Rust 的工作方式紧密相关。 在这里，我们将介绍一些更棘手的细微变化以及如何规划它们。 您会发现您需要在其中一些与您希望界面的灵活性之间取得平衡——有时，必须有所取舍。

### 类型修改

删除或重命名公共类型几乎肯定会破坏某些用户的代码。 为了解决这个问题，您需要尽可能利用 Rust 的可见性修饰符，例如 pub(crate) 和 pub(in path)。 拥有的公共类型越少，以后在不破坏现有代码的情况下更改内容的自由度就越大。

不过，用户代码可以通过更多方式依赖于您的类型，而不仅仅是名称。 考虑清单 3-3 中的公共类型和给定的使用那个代码。
```
// in your interface
pub struct Unit;
// in user code
let u = lib::Unit;
```
现在考虑如果您向 Unit 添加一个私有字段会发生什么。 即使您添加的字段是私有的，更改仍然会破坏用户的代码，因为他们依赖的构造函数已经消失。 同样，考虑清单 3-4 中的代码和使用。
```
// in your interface
pub struct Unit { pub field: bool };
// in user code
fn is_true(u: lib::Unit) -> bool {
    matches!(u, Unit { field: true })
}
```
在这里，向 Unit 添加私有字段也会破坏用户代码，这时因为 Rust 详尽的模式匹配检查逻辑能够看到用户看不到的部分接口。 它认识到还有更多字段，即使用户代码无法访问它们，并拒绝用户的不完整模式。 如果我们将元组结构转换为具有命名字段的常规结构，则会出现类似的问题：即使字段本身完全相同，任何旧模式也将不再对新类型定义有效。

Rust 提供了#[non_exhaustive] 属性来帮助缓解这些问题。 您可以将它添加到任何类型定义中，并且编译器将不允许使用隐式构造函数（如 lib::Unit { field1: true }）和非穷举模式匹配（即没有尾随 , .. 的模式） 那种。 如果您怀疑将来可能会修改特定类型，这是一个很好的添加属性。 不过，它确实限制了用户代码，例如通过剥夺用户依赖详尽模式匹配的能力，因此如果您认为给定类型可能保持稳定，请避免添加它。

### 类型实现 

正如您在第 2 章中回忆的那样，Rust 的一致性规则不允许对给定类型的给定特征进行多次实现。 由于我们不知道下游代码可能添加了哪些实现，因此添加现有特征的一揽子实现通常是一项重大更改。 这同样适用于为现有类型实现外部特征，或为外部类型实现现有特征——在这两种情况下，外部特征或类型的所有者可能会同时添加一个冲突的实现，因此这一定是一个重大变化。

删除特征实现是一个破坏性的变化，但是为新类型实现特征从来都不是问题，因为没有 crate 可以有与该类型冲突的实现。

也许违反直觉，你还想小心地为现有类型实现任何特征。 要了解原因，请考虑清单 3-5 中的代码。

```
// crate1 1.0
pub struct Unit;
put trait Foo1 { fn foo(&self) }
// note that Foo1 is not implemented for Unit
// crate2; depends on crate1 1.0
use crate1::{Unit, Foo1};
trait Foo2 { fn foo(&self) }
impl Foo2 for Unit { .. }
fn main() {
  Unit.foo();
}
```

如果您将 impl Foo1 for Unit 添加到 crate1 而没有将其标记为重大更改，则下游代码将突然停止编译，因为对 foo 的调用现在不明确。 如果下游 crate 使用通配符导入（使用 crate1::*），这甚至可以应用于新公共特征的实现。 如果您提供一个指示用户使用通配符导入的前奏模块，您将特别需要记住这一点。

对现有特征的大多数更改也是破坏性更改，例如更改方法签名或添加新方法。 更改方法签名会破坏特性的所有实现，可能还有很多使用，而添加新方法“只是”会破坏所有实现。 不过，添加具有默认实现的新方法很好，因为现有实现将继续适用。

我在这里说“一般”和“大多数”，因为作为接口作者，我们有一个可用的工具可以让我们规避其中的一些规则：密封特征。 密封的特征是只能被其他板条箱使用而不能实现的特征。 这立即使许多重大更改成为非重大更改。 例如，您可以向密封特征添加一个新方法，因为您知道当前 crate 之外没有任何实现需要考虑。 同样，您可以为新的外部类型实现密封特征，因为您知道定义该类型的外部包不能添加冲突的实现。

密封特征最常用于派生特征——为实现特定其他特征的类型提供全面实现的特征。 只有当外国板条箱实现你的特征没有意义时，你才应该密封一个特征； 它严重限制了 trait 的实用性，因为下游 crates 将不再能够为它们自己的类型实现它。 您还可以使用密封特征来限制哪些类型可以用作类型参数，例如将清单 3-2 中 Rocket 示例中的 Stage 类型限制为仅 Grounded 和 Launched 类型。

清单 3-6 显示了如何密封特征以及如何在定义包中仍然为它添加实现。

```
pub trait CanUseCannotImplement: sealed::Sealed 1 { .. } mod sealed {
pub trait Sealed {}
2 impl<T> Sealed for T where T: TraitBounds {}
}
impl<T> CanUseCannotImplement for T where T: TraitBounds {}
```
诀窍是添加一个私有的空特征作为您希望密封的特征 1 的超特征。由于超特征在私有模块中，其他板条箱无法访问它，因此无法实现它。 sealed trait 需要底层类型实现 Sealed，所以只有我们明确允许的类型 2 才能最终实现 trait。

> 如果你确实以这种方式密封了一个特征，请确保你记录了这个事实，这样用户就不会因为尝试自己实现这个特征而感到沮丧！


### 隐藏的合约

有时，您对代码的一部分所做的更改会以微妙的方式影响界面中其他地方的契约。 发生这种情况的两种主要方式是通过再出口和自动特征。

#### Re-Exports

如果你的接口的任何部分暴露了外来类型，那么对这些外来类型之一也是对您的接口的更改。 例如，考虑一下如果您移动到依赖项的新主要版本并将该依赖项中的类型公开为接口中的迭代器类型，会发生什么情况。 依赖于您的接口的用户也可能直接依赖于该依赖项，并期望您的接口提供的类型与该依赖项中同名的类型相同。 但是，如果您更改依赖项的主要版本，则即使类型名称相同，情况也不再如此。 清单 3-7 显示了一个这样的例子。

```
// your crate: bestiter
pub fn iter<T>() -> itercrate::Empty<T> { .. }
// their crate
struct EmptyIterator { it: itercrate::Empty<()> }
EmptyIterator { it: bestiter::iter() }
```
如果您的 crate 从 itercrate 1.0 移动到 itercrate 2.0 但其他方面没有改变，则此清单中的代码将不再编译。 即使类型没有改变，编译器（正确地）认为 itercrate1.0::Empty 和 itercrate2.0::Empty 是不同的类型。 因此，您不能将后者分配给前者，这使您的界面发生重大变化。

为了缓解此类问题，通常最好使用 newtype 模式包装外部类型，然后仅公开您认为有用的外部类型部分。 在许多情况下，您可以通过使用 impl Trait 仅向调用者提供非常小的合同来完全避免使用新类型包装器。 通过减少承诺，您可以减少破坏性更改。

> itercrate 示例可能误导了您。 如果 Empty 类型没有改变，那么为什么编译器不允许任何使用它的东西继续工作，无论代码使用的是版本 1.0 还是版本 2.0？ 答案是  。 . . 复杂 。 归结为 Rust 编译器不会假设仅仅因为两种类型具有相同的字段，它们就相同。 举一个简单的例子，假设 itercrate 2 .0 为 Empty 添加了一个 #[derive(Copy)] 。 现在，根据您使用的是 1 .0 还是 2 .0，该类型突然具有不同的移动语义！ 考虑到其中一个而编写的代码将无法与另一个一起使用。
>这个问题往往会出现在大型的、广泛使用的库中，随着时间的推移，可能必须在 crate 的某个地方发生重大更改。 不幸的是，语义版本控制发生在板条箱级别，而不是类型级别，因此任何地方的重大更改都是到处都是重大更改。  
>但一切都没有丢失。 几年前，David Tolnay（serde 的作者，以及大量其他 Rust 贡献者）提出了一个巧妙的技巧来处理这种情况。 他称之为“semver 技巧”。 这个想法很简单：如果某些类型 T 在重大更改（例如从 1 .0 到 2 .0）中保持不变，那么在发布 2 .0 之后，您可以发布一个新的 1 .0 次要版本，该版本依赖于 2 .0 并将 T 替换为从 2 .0 重新导出的 T。
> 通过这样做，您可以确保在两个主要版本中实际上只有一个类型 T。 反过来，这意味着任何依赖 1 .0 的板条箱都可以使用 2 .0 中的 T，反之亦然。 而且因为这只发生在你明确选择使用这个技巧的类型上，所以实际上破坏的变化将继续存在。  

#### Auto-Traits

Rust 有一些特性会根据该类型包含的内容自动为每种类型实现。 与本次讨论最相关的是 Send 和 Sync，尽管 Unpin、Sized 和 UnwindSafe 特征也有类似的问题。 就其本质而言，它们为您的界面中的几乎所有类型添加了一个隐藏的承诺。 这些特征甚至通过其他类型擦除的类型传播，如 impl Trait。

这些特征的实现（通常）由编译器自动添加，但这也意味着如果它们不再适用，它们不会自动添加。 因此，如果您有一个包含私有类型 B 的公共类型 A，并且您更改 B 使其不再是 Send，那么 A 现在也不是 Send。 这是一个突破性的变化！

这些更改可能很难跟踪，并且通常不会被发现，直到您的界面用户抱怨他们的代码不再有效。 为了在它们发生之前捕捉到这些情况，在您的测试套件中包含一些简单的测试是一种很好的做法，这些测试可以检查您的所有类型是否按照您期望的方式实现了这些特征。 清单 3-8 给出了此类测试的示例。

```
fn is_normal<T: Sized + Send + Sync + Unpin>() {}
#[test]
fn normal_types() {
  is_normal::<MyType>();
}
```
请注意，此测试不运行任何代码，而只是测试代码是否编译。 如果 MyType 不再实现 Sync，测试代码将无法编译，您将知道您刚刚所做的更改破坏了 auto-trait 实现。

> [doc(hidden)] 属性使您可以从文档中隐藏公共项，而不会使碰巧知道它存在的代码无法访问它。 这通常用于公开宏所需的方法和类型，但用户代码不需要。 这些隐藏项如何与您的接口契约交互是一个有争议的问题。 一般来说，标记为#[doc(hidden)] 的项目仅在其公共影响范围内被视为合同的一部分； 例如，如果用户代码最终可能包含隐藏类型，那么该类型是否为 Send 是契约的一部分，而其名称不是。 隐藏特性的隐藏固有方法和隐藏特性方法通常不是接口契约的一部分，尽管您应该确保在这些方法的文档中清楚地说明这一点。 是的，隐藏的物品仍应记录在案！

## 总结

在本章中，我们探讨了设计 Rust 接口的许多方面，无论它是供外部使用还是仅作为您的包中不同模块之间的抽象边界。 我们涵盖了很多具体的陷阱和技巧，但最终，高级原则应该指导您的思考：您的界面应该是普通的、灵活的、明显的和受约束的。 在下一章中，我们将深入研究如何在 Rust 代码中表示和处理错误。





