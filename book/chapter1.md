
#简介
当你深入 Rust 更高级的角落时，重要的是你要确保你对基本原理有着扎实的理解。在 Rust 中，和任何其他编程语言一样：各种关键字的准确含义和概念很重要，因为你开始
以更复杂的方式使用语言。 在本章节，我们将遍历 Rust 的许多原语并尝试更清楚地定义它们的含义、它们的工作原理以及它们为何完全如此。具体来说，我们将研究变量和值有何不同，它们在内存中的表示方式，以及程序具有的不同内存区域。 然后，我们将讨论您在继续阅读本书之前需要掌握的所有权、借用和生命周期的一些微妙之处。
如果愿意，您可以从头到尾阅读本章，也可以将其作为参考来温习您不太确定的概念。 我建议您在完全掌握本章的内容后再继续后续的阅读，因为对这些原语如何工作的误解会很快妨碍你理解更高级的主题，或者导致你错误地使用它们。

##谈谈内存
并非所有的内存都是平等的。在大多数编程环境下，你的程序可以访问栈（stack）、堆（heap）、寄存器（register）、文本段（text segment）、内存映射的寄存器（memory-mapped register）、内存映射文件（memory-mapped file），有时也会有非易失性可读写存储器（Nonvolatile RAM）。在特定的情况下，你选择使用哪一个会影响到你可以在那里存储什么、可以保持多长时间，以及使用什么机制来访问它。这些内存区域细节因平台而异，超出了本书的范围，但有些内存区域堆你如何推理 Rust 代码非常重要，因此值得在此介绍。

###内存术语
在深入研究内存区域之前，你首先需要了解 值（value）、变量（variable）和指针（pointer）之间的区别。Rust 中的值是一个类型和该类型值域[2]中的一个元素的组合。一个值可以根据其类型表征（type's representation）变成一串字节，但就这个词的本意而言，你可以认为一个值更像是“你 --程序员”这样的组合。例如， u8 类型中的数字 6是数学整数6的一个实例，它在内存中的表示是字节 0x06。同样，字符串 "hello world"是所有字符串域中的一个值，使用 UTF-8 编码来表示。一个值的意义与这些字节的存储位置无关。
值被存储于某个位置。位置（place）是 Rust 中的术语，意思是“一个可以容纳值的地方”。这个位置可以是栈，也可以是堆，或者是其他的某些位置。最常见的存储值的位置是一个变量，它是位于栈中的一个命名值槽（value slot）。指针是一个持有内存区域地址的值，所以指针指向某个位置。
我们可以通过解引用（dereference）指针来访问存储在它所指向内存位置的值。也可以在多个变量中存储相同的指针，这些变量正确地指向内存中的同一个位置，从而指向相同的值。
考虑清单 2-1 中的代码，它阐明了三个要素。
```
let x = 42; 
let y = 43;
let var1 = &x;
let mut var2 = &x;
var2 = &y;
```

代码中包含四个不同的值：42（i32 类型）、43（i32 类型）、x的地址（指针类型），以及 y 的地址（指针类型）。代码中也包含四个变量：x、y、var1 和 var2。后两个变量都持有指针类型的值，因为引用（reference）就是指针。虽然 var1 和 var2 最初存储的都是同一个值，但它们分布存储该值的独立副本。当我们改变 var2 (1) 存储的值时， var1 中的值不会改变。尤其是当 = 运算符将右侧表达式（expression）的值存储在左侧命名的地方。  
在一个语句（statement）中，变量、值和指针之间的区别很重要。下面是一个有趣的示例：
```
let string = "Hello world";
```
尽管我们给变量 string 赋予了一个字符串的值，但该变量的值实际上是一个指针，而不是字符串值本身。此时，你可能会说：“你等等，那么字符串的值是在哪里存储的呢？指针指向哪里？”。如果你真这么想，那说明你有一个敏锐的头脑。我们接下来就会解释这些问题。

###变量是什么
我前面给出的变量定义很宽泛，而且本身不太可能有什么用。当你遇到更复杂的代码时，你将需要一个更精准的心智模型（mental model）来帮助你推理程序的真正作用。我们可以利用许多这样的模型。详细描述这些模型会占用好几章的篇幅，也超出了本书的范围，但大致上它们可以分为两类：抽象模型（high-level model）和底层模型（low-level model）。抽象模型在思考生存期和借用层面的代码时很有用，而底层模型在推理 Unsafe 代码和 原始指针时很有用。下面两节中描述的变量模型对于本书中大部分内容来说已经足够了。

##high-level model
在抽象模型下，我们不认为变量是存放字节的地方。相反，我们认为它们只是在整个程序中被实例化、移动和使用时赋值的名称。当你给变量赋值的时候，这个值就以此变量为名。当变量在之后被访问时，你可以在脑海中从该变量之前的访问到最新的访问之间画一条线，来确定两个访问之间的依赖关系。如果变量的值被移动了，就不能再从它那里画线了。

在该模型中，只要一个变量持有合法的值，它就存在。如果一个变量的值未被初始化或被移动了，你就不能从它那里画线了，所以实际上它并不存在。使用此模型，你的整个程序就是由许多这样的依赖线组成，通常称之为流（flow），每条流都追踪一个值的特定实例的生存期。当有分支时，流可以分叉和合并，每个分叉都追踪该值的不同生存期。编译器可以检查你程序中的任何已知点，所有可以相互平行存在的流都是兼容的。例如，不能有两条并行的流对值进行可变访问。也不能有一条流借用一个值，但没有流拥有这个值。清单 2-2 展示了这两种情况。






